'use strict';

var React = require('react');
var moment = require('moment');

var TimeLine = React.createClass({
    displayName: 'TimeLine',


    contextTypes: {
        pointRadius: React.PropTypes.number,
        lineWidth: React.PropTypes.number,
        axeColor: React.PropTypes.string
    },

    getInitialState: function getInitialState() {
        return {
            hover: false
        };
    },
    setHover: function setHover(state) {
        this.setState({
            hover: state
        });
    },
    renderPathLine: function renderPathLine(index) {
        var lastX = this.props.lastX;
        if (!Boolean(lastX)) {
            return null;
        }

        var currentX = this.props.currentX;
        var currentPoint = this.props.points[index];
        var lastPoint = this.props.lastPoints[index];

        return React.createElement('line', { x1: lastX, y1: lastPoint.y, x2: currentX, y2: currentPoint.y,
            stroke: currentPoint.color, strokeWidth: this.context.lineWidth });
    },
    render: function render() {
        var that = this;
        var currentX = this.props.currentX;
        var lineTop = this.props.lineTop;
        var lineBottom = this.props.lineBottom;
        var points = this.props.points;

        var hover = this.state.hover;

        return React.createElement(
            'g',
            null,
            React.createElement('line', { x1: currentX, x2: currentX, y1: lineTop, y2: lineBottom,
                stroke: this.context.axeColor, strokeWidth: this.context.lineWidth }),
            points.map(function (point, index) {
                var color = point.color;
                // Default serie name to index
                var dataSerie = point.serie || index;

                return React.createElement(
                    'g',
                    { key: index },
                    that.renderPathLine(index),
                    React.createElement('circle', { key: index,
                        className: 'serie-point' + (hover ? ' hover' : ''),
                        onMouseEnter: that.setHover.bind(that, true),
                        onMouseLeave: that.setHover.bind(that, false),
                        r: that.context.pointRadius,
                        fill: color,
                        strokeWidth: that.context.lineWidth * 2,
                        stroke: '#FFFFFF',
                        cx: currentX,
                        cy: point.y,
                        'data-value': point.value,
                        'data-timestamp': Number(point.date),
                        'data-serie': dataSerie }),
                    '}'
                );
            })
        );
    }
});

var Body = React.createClass({
    displayName: 'Body',


    contextTypes: {
        seriesStyle: React.PropTypes.array,
        pointRadius: React.PropTypes.number,
        defaultColor: React.PropTypes.string,
        lineWidth: React.PropTypes.number,
        axeColor: React.PropTypes.string
    },

    // Compute X for a point inside Body
    innerPositionX: function innerPositionX(pX) {
        return this.props.innerX + pX * this.props.width;
    },


    // Compute Y for a point inside Body
    innerPositionY: function innerPositionY(pY) {
        return this.props.yBase + this.props.height * (1 - pY);
    },


    // Return inner X value for a date
    getInnerX: function getInnerX(date) {
        return this.innerPositionX((date - this.props.dateMin) / (this.props.dateMax - this.props.dateMin));
    },


    // Return inner Y value for a value
    getInnerY: function getInnerY(value) {
        return this.innerPositionY((value - this.props.valueMin) / (this.props.valueMax - this.props.valueMin));
    },


    // Return correct mapping for a point to draw in TimeLine
    formatPoint: function formatPoint(time, point, index) {
        var seriesStyle = this.context.seriesStyle;
        var serieStyle = seriesStyle[index];

        return {
            color: point.color || (serieStyle ? serieStyle.color : null) || this.context.defaultColor,
            value: point.value,
            serie: point.serie || (serieStyle ? serieStyle.title : index),
            date: time.date,
            y: this.getInnerY(point.value)
        };
    },


    // Draw this time line
    drawTimeLine: function drawTimeLine(time, i, series) {
        var that = this;

        // Current time informations
        var currentX = that.getInnerX(time.date);
        var lineTop = that.props.yBase;
        var lineBottom = that.props.yBase + that.props.height;

        var points = time.points.map(that.formatPoint.bind(that, time));

        // Last time informations
        var lastX = null;
        var lastPoints = null;
        var lastTime = series[i - 1];

        if (Boolean(lastTime)) {
            lastX = that.getInnerX(lastTime.date);
            lastPoints = lastTime.points.map(that.formatPoint.bind(that, lastTime));
        }

        return React.createElement(TimeLine, { key: i,
            currentX: currentX,
            lineTop: lineTop,
            lineBottom: lineBottom,
            points: points,
            lastX: lastX,
            lastPoints: lastPoints });
    },
    render: function render() {
        var series = this.props.series;

        return React.createElement(
            'g',
            null,
            series.map(this.drawTimeLine, this)
        );
    }
});

var XAxis = React.createClass({
    displayName: 'XAxis',


    contextTypes: {
        textColor: React.PropTypes.string,
        textFontSize: React.PropTypes.number,
        textFontFamily: React.PropTypes.string
    },

    getValuePerInterval: function getValuePerInterval() {
        var dateMin = this.props.dateMin;
        var dateMax = this.props.dateMax;

        // Get optimal interval for X axis
        return [{
            format: 'SSSS',
            interval: 1
        }, {
            format: 'SSSS',
            interval: 10
        }, {
            format: 'SSSS',
            interval: 100
        }, {
            format: 'H:mm:ss',
            interval: 1 * 1000
        }, {
            format: 'H:mm',
            interval: 60 * 1000
        }, {
            format: 'H',
            interval: 60 * 60 * 1000
        }, {
            format: 'DD/MM',
            interval: 1 * 24 * 60 * 60 * 1000
        }, {
            format: 'DD/MM',
            interval: 7 * 24 * 60 * 60 * 1000
        }, {
            format: 'DD/MM',
            interval: 30 * 24 * 60 * 60 * 1000
        }, {
            format: 'YYYY',
            interval: 365 * 24 * 60 * 60 * 1000
        }, {
            format: 'YYYY',
            interval: 10 * 365 * 24 * 60 * 60 * 1000
        }, {
            format: 'YYYY',
            interval: 100 * 365 * 24 * 60 * 60 * 1000
        }].filter(function (interval) {
            var count = (dateMax - dateMin) / interval.interval;
            return count > 1;
        }).map(function (interval) {
            var count = (dateMax - dateMin) / interval.interval;
            return { count: count, interval: interval };
        }).sort(function (a, b) {
            return a.count > b.count;
        })[0].interval;
    },
    render: function render() {
        var that = this;
        var dateMin = this.props.dateMin;
        var dateMax = this.props.dateMax;
        var length = this.props.length;
        var innerX = this.props.innerX;
        var yTop = this.props.yTop;

        // Compute intervals for rendering dates
        var valuePerInterval = this.getValuePerInterval();
        var wPerMS = length / (dateMax - dateMin);
        var axeXInterval = (dateMax - dateMin) * wPerMS / (this.context.textFontSize * 10);

        // Construct range of intervals
        var intervalRange = [];
        for (var i = 0; i < axeXInterval; i++) {
            intervalRange.push(i);
        }

        return React.createElement(
            'g',
            null,
            intervalRange.map(function (i) {
                var value = i * valuePerInterval.interval;
                var date = new Date(dateMin + value);

                var x = innerX + value * wPerMS;
                // Don't draw point if too far
                if (x > innerX + length) {
                    return null;
                }

                return React.createElement(
                    'text',
                    { key: i, x: x, y: yTop,
                        fontFamily: that.context.textFontFamily, fontSize: that.context.textFontSize,
                        fill: that.context.textColor, textAnchor: 'middle' },
                    moment(date).format(valuePerInterval.format)
                );
            })
        );
    }
});

var YAxis = React.createClass({
    displayName: 'YAxis',


    // Computes the optimal tick step for the Y axis
    // We assume: range = Math.abs(upper - lower)
    // i.e: range should not be negative
    optimalTickStep: function optimalTickStep(maxTicks) {
        var valueMin = this.props.valueMin;
        var valueMax = this.props.valueMax;

        var range = valueMax - valueMin;
        var minimum = range / maxTicks;
        var magnitude = Math.pow(10, Math.floor(Math.log(minimum) / Math.log(10)));
        var residual = minimum / magnitude;

        // Tick is an amplified magnitude
        // depending on the residual
        if (residual > 5) {
            return 10 * magnitude;
        } else if (residual > 2) {
            return 5 * magnitude;
        } else if (residual > 1) {
            return 2 * magnitude;
        }
        return magnitude;
    },


    contextTypes: {
        lineWidth: React.PropTypes.number,
        axeColor: React.PropTypes.string,
        axeMarkerWidth: React.PropTypes.number,
        textColor: React.PropTypes.string,
        textFontSize: React.PropTypes.number,
        textFontFamily: React.PropTypes.string
    },

    render: function render() {
        var that = this;
        var valueMin = this.props.valueMin;
        var valueMax = this.props.valueMax;
        var length = this.props.length;
        var axeYInterval = this.props.axeYInterval;
        var innerX = this.props.innerX;
        var innerY = this.props.innerY;
        var yBase = this.props.yBase;

        var hPerValue = length / (valueMax - valueMin);
        axeYInterval = (valueMax - valueMin) * hPerValue / (this.context.textFontSize * 4);

        // Calcul perfect value per interval (1, 10, 100, 1000, ...)
        var valuePerInterval = that.optimalTickStep(axeYInterval);
        // Construct range of intervals
        var intervalRange = [];
        for (var i = 0; i < axeYInterval + 1; i++) {
            intervalRange.push(i);
        }

        return React.createElement(
            'g',
            null,
            intervalRange.map(function (i) {
                var value = i * valuePerInterval;
                var y = innerY - value * hPerValue;
                var displayValue = value + valueMin;

                // Don't draw point if is too high
                if (y < yBase) {
                    return null;
                }

                var textX = innerX - 2 * that.context.axeMarkerWidth;
                var lineX1 = innerX - that.context.axeMarkerWidth;
                var lineX2 = innerX;

                return React.createElement(
                    'g',
                    { key: i },
                    React.createElement(
                        'text',
                        { x: textX, y: y,
                            fontFamily: that.context.textFontFamily, fontSize: that.context.textFontSize,
                            textAnchor: 'end', fill: that.context.textColor },
                        displayValue
                    ),
                    React.createElement('line', { x1: lineX1, x2: lineX2, y1: y, y2: y,
                        stroke: that.context.axeColor, strokeWidth: that.context.lineWidth })
                );
            })
        );
    }
});

var TimeGraph = React.createClass({
    displayName: 'TimeGraph',


    childContextTypes: {
        seriesStyle: React.PropTypes.array,
        pointRadius: React.PropTypes.number,
        defaultColor: React.PropTypes.string,
        lineWidth: React.PropTypes.number,

        axeColor: React.PropTypes.string,
        axeMarkerWidth: React.PropTypes.number,

        textColor: React.PropTypes.string,
        textFontSize: React.PropTypes.number,
        textFontFamily: React.PropTypes.string
    },

    getDefaultProps: function getDefaultProps() {
        return {
            // Autofill
            autoFill: false,
            autoFillValue: 0,
            autoFillInterval: 1000 * 60 * 60 * 24,
            autoFillStartTime: null,
            autoFillEndTime: null,

            // Size
            width: 800,
            height: 400,
            padding: 20,

            // Styling
            pointRadius: 4,
            lineWidth: 1,
            defaultColor: '#1db34f',

            axeColor: '#eee',
            axeMarkerWidth: 10,

            textColor: '#aaa',
            textFontSize: 10,
            textFontFamily: 'helvetica'
        };
    },
    getChildContext: function getChildContext() {
        return {
            seriesStyle: this.props.seriesStyle,
            pointRadius: this.props.pointRadius,
            defaultColor: this.props.defaultColor,
            lineWidth: this.props.lineWidth,
            axeColor: this.props.axeColor,
            axeMarkerWidth: this.props.axeMarkerWidth,
            textColor: this.props.textColor,
            textFontSize: this.props.textFontSize,
            textFontFamily: this.props.textFontFamily
        };
    },
    getInitialState: function getInitialState() {
        return this.getStateFromProps(this.props);
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
        this.setState(this.getStateFromProps(nextProps));
    },
    getStateFromProps: function getStateFromProps(props) {
        var width = props.width;
        var height = props.height;
        var padding = props.padding;
        var series = props.series;
        var minValue = props.minValue;
        var defaultColor = props.defaultColor;
        var seriesStyle = props.seriesStyle;

        // Compute values ranges
        var dateMin = null;
        var dateMax = null;
        var valueMin = null;
        var valueMax = null;

        series = series.map(function (time, i) {
            // Set min/max dates
            var date = new Date(time.date).getTime();
            dateMin = Boolean(dateMin) ? Math.min(dateMin, date) : date;
            dateMax = Boolean(dateMax) ? Math.max(dateMax, date) : date;

            // Set min/max values
            var points = time.points;
            points.forEach(function (point) {
                var value = point.value;
                valueMin = Boolean(valueMin) ? Math.min(valueMin, value) : value;
                valueMax = Boolean(valueMax) ? Math.max(valueMax, value) : value;
            });

            return {
                date: date,
                points: points
            };
        });

        // Sort by date
        series.sort(function (a, b) {
            return a.date - b.date;
        });

        // Set minValue if set
        if (typeof minValue != 'undefined' && minValue < valueMin) {
            valueMin = minValue;
        }

        // Auto-fill
        if (props.autoFill) {
            var autoFillStartTime = props.autoFillStartTime;
            var autoFillEndTime = props.autoFillEndTime;
            var autoFillInterval = props.autoFillInterval;
            var autoFillValue = props.autoFillValue;

            // Set autoFill times to timestamps if provided
            if (Boolean(autoFillStartTime)) {
                autoFillStartTime = new Date(autoFillStartTime).getTime();
            }
            if (Boolean(autoFillEndTime)) {
                autoFillEndTime = new Date(autoFillEndTime).getTime();
            }
            // Set start and end time depending on options
            dateMin = Boolean(autoFillStartTime) ? autoFillStartTime : dateMin;
            dateMax = Boolean(autoFillEndTime) ? autoFillEndTime : dateMax;

            // Set endTime to construct serie
            var serieEndTime = Boolean(autoFillEndTime) ? dateMax : dateMax + autoFillInterval;

            // Set valueMin and valueMax
            valueMin = Math.min(valueMin, autoFillValue);
            valueMax = Math.max(valueMax, autoFillValue);

            // Construct time range
            var timeRange = [];
            for (var t = dateMin; t < serieEndTime; t += autoFillInterval) {
                timeRange.push(t);
            }

            // Fill current serie with existing points or with autoFillValue
            var seriesIndex = 0;

            series = timeRange.map(function (time, i) {
                var data = series[seriesIndex];

                if (Boolean(data) && data.date == time) {
                    seriesIndex++;
                    return data;
                } else {
                    // Construct missing points
                    return {
                        date: time,
                        points: seriesStyle.map(function (style, i) {
                            return {
                                serie: style.title || i,
                                value: autoFillValue,
                                color: style.color || defaultColor
                            };
                        })
                    };
                }
            });
        }

        if (valueMax == valueMin) {
            valueMax = valueMin + 1;
        }

        // Compute axe sizes
        var axeXHeight = props.textFontSize * 3;
        var axeYWidth = valueMax.toFixed(0).length * props.textFontSize * 1.5 + props.axeMarkerWidth;

        var axeXLength = width - 2 * padding - axeYWidth;
        var axeYLength = height - 2 * padding - axeXHeight;

        // Compute body size
        var innerX = axeYWidth + padding;
        var innerY = height - (axeXHeight + padding);

        var yBase = padding;
        var yTop = height - padding;

        return {
            width: width,
            height: height,
            series: series,
            dateMin: dateMin,
            dateMax: dateMax,
            valueMin: valueMin,
            valueMax: valueMax,
            axeXLength: axeXLength,
            axeYLength: axeYLength,
            innerX: innerX,
            innerY: innerY,
            yTop: yTop,
            yBase: yBase
        };
    },
    render: function render() {
        var width = this.state.width;
        var height = this.state.height;
        var series = this.state.series;
        var dateMin = this.state.dateMin;
        var dateMax = this.state.dateMax;
        var valueMin = this.state.valueMin;
        var valueMax = this.state.valueMax;
        var axeXLength = this.state.axeXLength;
        var axeYLength = this.state.axeYLength;
        var innerX = this.state.innerX;
        var innerY = this.state.innerY;
        var yTop = this.state.yTop;
        var yBase = this.state.yBase;

        return React.createElement(
            'svg',
            { className: 'time-graph', width: width, height: height, viewBox: '0 0 ' + width + ' ' + height, preserveAspectRatio: 'xMidYMid meet' },
            React.createElement(XAxis, { length: axeXLength,
                dateMin: dateMin,
                dateMax: dateMax,
                innerX: innerX,
                yTop: yTop }),
            React.createElement(YAxis, { length: axeYLength,
                valueMin: valueMin,
                valueMax: valueMax,
                innerX: innerX,
                innerY: innerY,
                yBase: yBase }),
            React.createElement(Body, { series: series,
                dateMin: dateMin,
                dateMax: dateMax,
                valueMin: valueMin,
                valueMax: valueMax,
                width: axeXLength,
                height: axeYLength,
                innerX: innerX,
                innerY: innerY,
                yBase: yBase })
        );
    }
});

module.exports = TimeGraph;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9UaW1lR3JhcGguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFNLFFBQVMsUUFBUSxPQUFSLENBQWY7QUFDQSxJQUFNLFNBQVMsUUFBUSxRQUFSLENBQWY7O0FBRUEsSUFBTSxXQUFXLE1BQU0sV0FBTixDQUFrQjtBQUFBOzs7QUFVL0Isa0JBQWM7QUFDVixxQkFBYSxNQUFNLFNBQU4sQ0FBZ0IsTUFEbkI7QUFFVixtQkFBYSxNQUFNLFNBQU4sQ0FBZ0IsTUFGbkI7QUFHVixrQkFBYSxNQUFNLFNBQU4sQ0FBZ0I7QUFIbkIsS0FWaUI7O0FBZ0IvQixtQkFoQitCLDZCQWdCYjtBQUNkLGVBQU87QUFDSCxtQkFBTztBQURKLFNBQVA7QUFHSCxLQXBCOEI7QUFzQi9CLFlBdEIrQixvQkFzQnRCLEtBdEJzQixFQXNCZjtBQUNaLGFBQUssUUFBTCxDQUFjO0FBQ1YsbUJBQU87QUFERyxTQUFkO0FBR0gsS0ExQjhCO0FBNEIvQixrQkE1QitCLDBCQTRCaEIsS0E1QmdCLEVBNEJUO0FBQ2xCLFlBQUksUUFBUSxLQUFLLEtBQUwsQ0FBVyxLQUF2QjtBQUNBLFlBQUksQ0FBQyxRQUFRLEtBQVIsQ0FBTCxFQUFxQjtBQUNqQixtQkFBTyxJQUFQO0FBQ0g7O0FBRUQsWUFBSSxXQUFlLEtBQUssS0FBTCxDQUFXLFFBQTlCO0FBQ0EsWUFBSSxlQUFlLEtBQUssS0FBTCxDQUFXLE1BQVgsQ0FBa0IsS0FBbEIsQ0FBbkI7QUFDQSxZQUFJLFlBQWUsS0FBSyxLQUFMLENBQVcsVUFBWCxDQUFzQixLQUF0QixDQUFuQjs7QUFFQSxlQUFPLDhCQUFNLElBQUksS0FBVixFQUFpQixJQUFJLFVBQVUsQ0FBL0IsRUFBa0MsSUFBSSxRQUF0QyxFQUFnRCxJQUFJLGFBQWEsQ0FBakU7QUFDSCxvQkFBUSxhQUFhLEtBRGxCLEVBQ3lCLGFBQWEsS0FBSyxPQUFMLENBQWEsU0FEbkQsR0FBUDtBQUVILEtBeEM4QjtBQTBDL0IsVUExQytCLG9CQTBDdEI7QUFDTCxZQUFJLE9BQWEsSUFBakI7QUFDQSxZQUFJLFdBQWEsS0FBSyxLQUFMLENBQVcsUUFBNUI7QUFDQSxZQUFJLFVBQWEsS0FBSyxLQUFMLENBQVcsT0FBNUI7QUFDQSxZQUFJLGFBQWEsS0FBSyxLQUFMLENBQVcsVUFBNUI7QUFDQSxZQUFJLFNBQWEsS0FBSyxLQUFMLENBQVcsTUFBNUI7O0FBRUEsWUFBSSxRQUFRLEtBQUssS0FBTCxDQUFXLEtBQXZCOztBQUVBLGVBQ0k7QUFBQTtBQUFBO0FBQ0ksMENBQU0sSUFBSSxRQUFWLEVBQW9CLElBQUksUUFBeEIsRUFBa0MsSUFBSSxPQUF0QyxFQUErQyxJQUFJLFVBQW5EO0FBQ0ksd0JBQVEsS0FBSyxPQUFMLENBQWEsUUFEekIsRUFDbUMsYUFBYSxLQUFLLE9BQUwsQ0FBYSxTQUQ3RCxHQURKO0FBSUssbUJBQU8sR0FBUCxDQUFXLFVBQVMsS0FBVCxFQUFnQixLQUFoQixFQUF1QjtBQUMvQixvQkFBSSxRQUFhLE1BQU0sS0FBdkI7QUFDQTtBQUNBLG9CQUFJLFlBQWEsTUFBTSxLQUFOLElBQWUsS0FBaEM7O0FBRUEsdUJBQ0k7QUFBQTtBQUFBLHNCQUFHLEtBQUssS0FBUjtBQUNLLHlCQUFLLGNBQUwsQ0FBb0IsS0FBcEIsQ0FETDtBQUVJLG9EQUFRLEtBQUssS0FBYjtBQUNJLG1DQUFXLGlCQUFlLFFBQU8sUUFBUCxHQUFrQixFQUFqQyxDQURmO0FBRUksc0NBQWMsS0FBSyxRQUFMLENBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QixJQUF6QixDQUZsQjtBQUdJLHNDQUFjLEtBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsS0FBekIsQ0FIbEI7QUFJSSwyQkFBRyxLQUFLLE9BQUwsQ0FBYSxXQUpwQjtBQUtJLDhCQUFNLEtBTFY7QUFNSSxxQ0FBYSxLQUFLLE9BQUwsQ0FBYSxTQUFiLEdBQXlCLENBTjFDO0FBT0ksZ0NBQU8sU0FQWDtBQVFJLDRCQUFJLFFBUlI7QUFTSSw0QkFBSSxNQUFNLENBVGQ7QUFVSSxzQ0FBWSxNQUFNLEtBVnRCO0FBV0ksMENBQWdCLE9BQU8sTUFBTSxJQUFiLENBWHBCO0FBWUksc0NBQVksU0FaaEIsR0FGSjtBQUFBO0FBQUEsaUJBREo7QUFtQkgsYUF4QkE7QUFKTCxTQURKO0FBZ0NIO0FBbkY4QixDQUFsQixDQUFqQjs7QUFzRkEsSUFBSSxPQUFPLE1BQU0sV0FBTixDQUFrQjtBQUFBOzs7QUFjekIsa0JBQWM7QUFDVixxQkFBYyxNQUFNLFNBQU4sQ0FBZ0IsS0FEcEI7QUFFVixxQkFBYyxNQUFNLFNBQU4sQ0FBZ0IsTUFGcEI7QUFHVixzQkFBYyxNQUFNLFNBQU4sQ0FBZ0IsTUFIcEI7QUFJVixtQkFBYyxNQUFNLFNBQU4sQ0FBZ0IsTUFKcEI7QUFLVixrQkFBYyxNQUFNLFNBQU4sQ0FBZ0I7QUFMcEIsS0FkVzs7QUFzQnpCO0FBQ0Esa0JBdkJ5QiwwQkF1QlYsRUF2QlUsRUF1Qk47QUFDZixlQUFPLEtBQUssS0FBTCxDQUFXLE1BQVgsR0FBb0IsS0FBRyxLQUFLLEtBQUwsQ0FBVyxLQUF6QztBQUNILEtBekJ3Qjs7O0FBMkJ6QjtBQUNBLGtCQTVCeUIsMEJBNEJWLEVBNUJVLEVBNEJOO0FBQ2YsZUFBTyxLQUFLLEtBQUwsQ0FBVyxLQUFYLEdBQW9CLEtBQUssS0FBTCxDQUFXLE1BQVgsSUFBcUIsSUFBSSxFQUF6QixDQUEzQjtBQUNILEtBOUJ3Qjs7O0FBZ0N6QjtBQUNBLGFBakN5QixxQkFpQ2YsSUFqQ2UsRUFpQ1Q7QUFDWixlQUFPLEtBQUssY0FBTCxDQUFvQixDQUFDLE9BQU8sS0FBSyxLQUFMLENBQVcsT0FBbkIsS0FBNkIsS0FBSyxLQUFMLENBQVcsT0FBWCxHQUFxQixLQUFLLEtBQUwsQ0FBVyxPQUE3RCxDQUFwQixDQUFQO0FBQ0gsS0FuQ3dCOzs7QUFxQ3pCO0FBQ0EsYUF0Q3lCLHFCQXNDZixLQXRDZSxFQXNDUjtBQUNiLGVBQU8sS0FBSyxjQUFMLENBQW9CLENBQUMsUUFBUSxLQUFLLEtBQUwsQ0FBVyxRQUFwQixLQUErQixLQUFLLEtBQUwsQ0FBVyxRQUFYLEdBQXNCLEtBQUssS0FBTCxDQUFXLFFBQWhFLENBQXBCLENBQVA7QUFDSCxLQXhDd0I7OztBQTBDekI7QUFDQSxlQTNDeUIsdUJBMkNiLElBM0NhLEVBMkNQLEtBM0NPLEVBMkNBLEtBM0NBLEVBMkNPO0FBQzVCLFlBQUksY0FBYyxLQUFLLE9BQUwsQ0FBYSxXQUEvQjtBQUNBLFlBQUksYUFBYSxZQUFZLEtBQVosQ0FBakI7O0FBRUEsZUFBTztBQUNILG1CQUFPLE1BQU0sS0FBTixLQUFnQixhQUFZLFdBQVcsS0FBdkIsR0FBK0IsSUFBL0MsS0FBd0QsS0FBSyxPQUFMLENBQWEsWUFEekU7QUFFSCxtQkFBTyxNQUFNLEtBRlY7QUFHSCxtQkFBTyxNQUFNLEtBQU4sS0FBZ0IsYUFBWSxXQUFXLEtBQXZCLEdBQStCLEtBQS9DLENBSEo7QUFJSCxrQkFBTyxLQUFLLElBSlQ7QUFLSCxlQUFPLEtBQUssU0FBTCxDQUFlLE1BQU0sS0FBckI7QUFMSixTQUFQO0FBT0gsS0F0RHdCOzs7QUF3RHpCO0FBQ0EsZ0JBekR5Qix3QkF5RFosSUF6RFksRUF5RE4sQ0F6RE0sRUF5REgsTUF6REcsRUF5REs7QUFDMUIsWUFBSSxPQUFPLElBQVg7O0FBRUE7QUFDQSxZQUFJLFdBQWEsS0FBSyxTQUFMLENBQWUsS0FBSyxJQUFwQixDQUFqQjtBQUNBLFlBQUksVUFBYSxLQUFLLEtBQUwsQ0FBVyxLQUE1QjtBQUNBLFlBQUksYUFBYSxLQUFLLEtBQUwsQ0FBVyxLQUFYLEdBQW1CLEtBQUssS0FBTCxDQUFXLE1BQS9DOztBQUVBLFlBQUksU0FBUyxLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQWdCLEtBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixJQUF0QixFQUE0QixJQUE1QixDQUFoQixDQUFiOztBQUVBO0FBQ0EsWUFBSSxRQUFhLElBQWpCO0FBQ0EsWUFBSSxhQUFhLElBQWpCO0FBQ0EsWUFBSSxXQUFhLE9BQU8sSUFBSSxDQUFYLENBQWpCOztBQUVBLFlBQUksUUFBUSxRQUFSLENBQUosRUFBdUI7QUFDbkIsb0JBQWEsS0FBSyxTQUFMLENBQWUsU0FBUyxJQUF4QixDQUFiO0FBQ0EseUJBQWEsU0FBUyxNQUFULENBQWdCLEdBQWhCLENBQW9CLEtBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixJQUF0QixFQUE0QixRQUE1QixDQUFwQixDQUFiO0FBQ0g7O0FBRUQsZUFDSSxvQkFBQyxRQUFELElBQVUsS0FBSyxDQUFmO0FBQ0ksc0JBQVUsUUFEZDtBQUVJLHFCQUFTLE9BRmI7QUFHSSx3QkFBWSxVQUhoQjtBQUlJLG9CQUFRLE1BSlo7QUFLSSxtQkFBTyxLQUxYO0FBTUksd0JBQVksVUFOaEIsR0FESjtBQVNILEtBdEZ3QjtBQXdGekIsVUF4RnlCLG9CQXdGaEI7QUFDTCxZQUFJLFNBQVMsS0FBSyxLQUFMLENBQVcsTUFBeEI7O0FBRUEsZUFDSTtBQUFBO0FBQUE7QUFDQyxtQkFBTyxHQUFQLENBQVcsS0FBSyxZQUFoQixFQUE4QixJQUE5QjtBQURELFNBREo7QUFLSDtBQWhHd0IsQ0FBbEIsQ0FBWDs7QUFtR0EsSUFBSSxRQUFRLE1BQU0sV0FBTixDQUFrQjtBQUFBOzs7QUFTMUIsa0JBQWM7QUFDVixtQkFBZ0IsTUFBTSxTQUFOLENBQWdCLE1BRHRCO0FBRVYsc0JBQWdCLE1BQU0sU0FBTixDQUFnQixNQUZ0QjtBQUdWLHdCQUFnQixNQUFNLFNBQU4sQ0FBZ0I7QUFIdEIsS0FUWTs7QUFlMUIsdUJBZjBCLGlDQWVKO0FBQ2xCLFlBQUksVUFBVSxLQUFLLEtBQUwsQ0FBVyxPQUF6QjtBQUNBLFlBQUksVUFBVSxLQUFLLEtBQUwsQ0FBVyxPQUF6Qjs7QUFFQTtBQUNBLGVBQU8sQ0FDSDtBQUNJLG9CQUFRLE1BRFo7QUFFSSxzQkFBVTtBQUZkLFNBREcsRUFLSDtBQUNJLG9CQUFRLE1BRFo7QUFFSSxzQkFBVTtBQUZkLFNBTEcsRUFTSDtBQUNJLG9CQUFRLE1BRFo7QUFFSSxzQkFBVTtBQUZkLFNBVEcsRUFhSDtBQUNJLG9CQUFRLFNBRFo7QUFFSSxzQkFBVSxJQUFFO0FBRmhCLFNBYkcsRUFpQkg7QUFDSSxvQkFBUSxNQURaO0FBRUksc0JBQVUsS0FBRztBQUZqQixTQWpCRyxFQXFCSDtBQUNJLG9CQUFRLEdBRFo7QUFFSSxzQkFBVSxLQUFHLEVBQUgsR0FBTTtBQUZwQixTQXJCRyxFQXlCSDtBQUNJLG9CQUFRLE9BRFo7QUFFSSxzQkFBVSxJQUFFLEVBQUYsR0FBSyxFQUFMLEdBQVEsRUFBUixHQUFXO0FBRnpCLFNBekJHLEVBNkJIO0FBQ0ksb0JBQVEsT0FEWjtBQUVJLHNCQUFVLElBQUUsRUFBRixHQUFLLEVBQUwsR0FBUSxFQUFSLEdBQVc7QUFGekIsU0E3QkcsRUFpQ0g7QUFDSSxvQkFBUSxPQURaO0FBRUksc0JBQVUsS0FBRyxFQUFILEdBQU0sRUFBTixHQUFTLEVBQVQsR0FBWTtBQUYxQixTQWpDRyxFQXFDSDtBQUNJLG9CQUFRLE1BRFo7QUFFSSxzQkFBVSxNQUFJLEVBQUosR0FBTyxFQUFQLEdBQVUsRUFBVixHQUFhO0FBRjNCLFNBckNHLEVBeUNIO0FBQ0ksb0JBQVEsTUFEWjtBQUVJLHNCQUFVLEtBQUcsR0FBSCxHQUFPLEVBQVAsR0FBVSxFQUFWLEdBQWEsRUFBYixHQUFnQjtBQUY5QixTQXpDRyxFQTZDSDtBQUNJLG9CQUFRLE1BRFo7QUFFSSxzQkFBVSxNQUFJLEdBQUosR0FBUSxFQUFSLEdBQVcsRUFBWCxHQUFjLEVBQWQsR0FBaUI7QUFGL0IsU0E3Q0csRUFpREwsTUFqREssQ0FpREUsVUFBUyxRQUFULEVBQW1CO0FBQ3hCLGdCQUFJLFFBQVEsQ0FBQyxVQUFVLE9BQVgsSUFBb0IsU0FBUyxRQUF6QztBQUNBLG1CQUFPLFFBQVEsQ0FBZjtBQUNILFNBcERNLEVBcUROLEdBckRNLENBcURGLFVBQVMsUUFBVCxFQUFtQjtBQUNwQixnQkFBSSxRQUFRLENBQUMsVUFBVSxPQUFYLElBQW9CLFNBQVMsUUFBekM7QUFDQSxtQkFBTyxFQUFFLFlBQUYsRUFBUyxrQkFBVCxFQUFQO0FBQ0gsU0F4RE0sRUF5RE4sSUF6RE0sQ0F5REQsVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQ2pCLG1CQUFPLEVBQUUsS0FBRixHQUFVLEVBQUUsS0FBbkI7QUFDSCxTQTNETSxFQTJESixDQTNESSxFQTJERCxRQTNETjtBQTRESCxLQWhGeUI7QUFrRjFCLFVBbEYwQixvQkFrRmpCO0FBQ0wsWUFBSSxPQUFVLElBQWQ7QUFDQSxZQUFJLFVBQVUsS0FBSyxLQUFMLENBQVcsT0FBekI7QUFDQSxZQUFJLFVBQVUsS0FBSyxLQUFMLENBQVcsT0FBekI7QUFDQSxZQUFJLFNBQVUsS0FBSyxLQUFMLENBQVcsTUFBekI7QUFDQSxZQUFJLFNBQVUsS0FBSyxLQUFMLENBQVcsTUFBekI7QUFDQSxZQUFJLE9BQVUsS0FBSyxLQUFMLENBQVcsSUFBekI7O0FBRUE7QUFDQSxZQUFJLG1CQUFtQixLQUFLLG1CQUFMLEVBQXZCO0FBQ0EsWUFBSSxTQUFtQixVQUFRLFVBQVUsT0FBbEIsQ0FBdkI7QUFDQSxZQUFJLGVBQW9CLENBQUMsVUFBVSxPQUFYLElBQXNCLE1BQXZCLElBQWtDLEtBQUssT0FBTCxDQUFhLFlBQWIsR0FBNEIsRUFBOUQsQ0FBdkI7O0FBRUE7QUFDQSxZQUFJLGdCQUFnQixFQUFwQjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxZQUFwQixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQywwQkFBYyxJQUFkLENBQW1CLENBQW5CO0FBQ0g7O0FBRUQsZUFDSTtBQUFBO0FBQUE7QUFDQywwQkFBYyxHQUFkLENBQWtCLFVBQVMsQ0FBVCxFQUFZO0FBQzNCLG9CQUFJLFFBQVEsSUFBSSxpQkFBaUIsUUFBakM7QUFDQSxvQkFBSSxPQUFRLElBQUksSUFBSixDQUFTLFVBQVUsS0FBbkIsQ0FBWjs7QUFFQSxvQkFBSSxJQUFJLFNBQVUsUUFBUSxNQUExQjtBQUNBO0FBQ0Esb0JBQUksSUFBSSxTQUFTLE1BQWpCLEVBQXlCO0FBQ3JCLDJCQUFPLElBQVA7QUFDSDs7QUFFRCx1QkFBTztBQUFBO0FBQUEsc0JBQU0sS0FBSyxDQUFYLEVBQWMsR0FBRyxDQUFqQixFQUFvQixHQUFHLElBQXZCO0FBQ0gsb0NBQVksS0FBSyxPQUFMLENBQWEsY0FEdEIsRUFDc0MsVUFBVSxLQUFLLE9BQUwsQ0FBYSxZQUQ3RDtBQUVILDhCQUFNLEtBQUssT0FBTCxDQUFhLFNBRmhCLEVBRTJCLFlBQVcsUUFGdEM7QUFFZ0QsMkJBQU8sSUFBUCxFQUFhLE1BQWIsQ0FBb0IsaUJBQWlCLE1BQXJDO0FBRmhELGlCQUFQO0FBR0gsYUFiQTtBQURELFNBREo7QUFrQkg7QUF2SHlCLENBQWxCLENBQVo7O0FBMEhBLElBQUksUUFBUSxNQUFNLFdBQU4sQ0FBa0I7QUFBQTs7O0FBVzFCO0FBQ0E7QUFDQTtBQUNBLG1CQWQwQiwyQkFjVixRQWRVLEVBY0E7QUFDdEIsWUFBSSxXQUFXLEtBQUssS0FBTCxDQUFXLFFBQTFCO0FBQ0EsWUFBSSxXQUFXLEtBQUssS0FBTCxDQUFXLFFBQTFCOztBQUVBLFlBQUksUUFBWSxXQUFXLFFBQTNCO0FBQ0EsWUFBSSxVQUFZLFFBQVEsUUFBeEI7QUFDQSxZQUFJLFlBQVksS0FBSyxHQUFMLENBQVMsRUFBVCxFQUFhLEtBQUssS0FBTCxDQUFXLEtBQUssR0FBTCxDQUFTLE9BQVQsSUFBb0IsS0FBSyxHQUFMLENBQVMsRUFBVCxDQUEvQixDQUFiLENBQWhCO0FBQ0EsWUFBSSxXQUFZLFVBQVUsU0FBMUI7O0FBRUE7QUFDQTtBQUNBLFlBQUksV0FBVyxDQUFmLEVBQWtCO0FBQ2QsbUJBQU8sS0FBSyxTQUFaO0FBQ0gsU0FGRCxNQUVPLElBQUksV0FBVyxDQUFmLEVBQWtCO0FBQ3JCLG1CQUFPLElBQUksU0FBWDtBQUNILFNBRk0sTUFFQSxJQUFJLFdBQVcsQ0FBZixFQUFrQjtBQUNyQixtQkFBTyxJQUFJLFNBQVg7QUFDSDtBQUNELGVBQU8sU0FBUDtBQUNILEtBakN5Qjs7O0FBbUMxQixrQkFBYztBQUNWLG1CQUFnQixNQUFNLFNBQU4sQ0FBZ0IsTUFEdEI7QUFFVixrQkFBZ0IsTUFBTSxTQUFOLENBQWdCLE1BRnRCO0FBR1Ysd0JBQWdCLE1BQU0sU0FBTixDQUFnQixNQUh0QjtBQUlWLG1CQUFnQixNQUFNLFNBQU4sQ0FBZ0IsTUFKdEI7QUFLVixzQkFBZ0IsTUFBTSxTQUFOLENBQWdCLE1BTHRCO0FBTVYsd0JBQWdCLE1BQU0sU0FBTixDQUFnQjtBQU50QixLQW5DWTs7QUE0QzFCLFVBNUMwQixvQkE0Q2pCO0FBQ0wsWUFBSSxPQUFlLElBQW5CO0FBQ0EsWUFBSSxXQUFlLEtBQUssS0FBTCxDQUFXLFFBQTlCO0FBQ0EsWUFBSSxXQUFlLEtBQUssS0FBTCxDQUFXLFFBQTlCO0FBQ0EsWUFBSSxTQUFlLEtBQUssS0FBTCxDQUFXLE1BQTlCO0FBQ0EsWUFBSSxlQUFlLEtBQUssS0FBTCxDQUFXLFlBQTlCO0FBQ0EsWUFBSSxTQUFlLEtBQUssS0FBTCxDQUFXLE1BQTlCO0FBQ0EsWUFBSSxTQUFlLEtBQUssS0FBTCxDQUFXLE1BQTlCO0FBQ0EsWUFBSSxRQUFlLEtBQUssS0FBTCxDQUFXLEtBQTlCOztBQUVBLFlBQUksWUFBZSxVQUFRLFdBQVcsUUFBbkIsQ0FBbkI7QUFDQSx1QkFBZ0IsQ0FBQyxXQUFXLFFBQVosSUFBd0IsU0FBekIsSUFBdUMsS0FBSyxPQUFMLENBQWEsWUFBYixHQUE0QixDQUFuRSxDQUFmOztBQUVBO0FBQ0EsWUFBSSxtQkFBbUIsS0FBSyxlQUFMLENBQXFCLFlBQXJCLENBQXZCO0FBQ0E7QUFDQSxZQUFJLGdCQUFnQixFQUFwQjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxlQUFhLENBQWpDLEVBQW9DLEdBQXBDLEVBQXlDO0FBQ3JDLDBCQUFjLElBQWQsQ0FBbUIsQ0FBbkI7QUFDSDs7QUFFRCxlQUNJO0FBQUE7QUFBQTtBQUNLLDBCQUFjLEdBQWQsQ0FBa0IsVUFBUyxDQUFULEVBQVk7QUFDM0Isb0JBQUksUUFBZSxJQUFJLGdCQUF2QjtBQUNBLG9CQUFJLElBQWUsU0FBVSxRQUFRLFNBQXJDO0FBQ0Esb0JBQUksZUFBZSxRQUFRLFFBQTNCOztBQUVBO0FBQ0Esb0JBQUksSUFBSSxLQUFSLEVBQWU7QUFDWCwyQkFBTyxJQUFQO0FBQ0g7O0FBRUQsb0JBQUksUUFBUyxTQUFVLElBQUUsS0FBSyxPQUFMLENBQWEsY0FBdEM7QUFDQSxvQkFBSSxTQUFTLFNBQVMsS0FBSyxPQUFMLENBQWEsY0FBbkM7QUFDQSxvQkFBSSxTQUFTLE1BQWI7O0FBRUEsdUJBQ0k7QUFBQTtBQUFBLHNCQUFHLEtBQUssQ0FBUjtBQUNJO0FBQUE7QUFBQSwwQkFBTSxHQUFHLEtBQVQsRUFBZ0IsR0FBRyxDQUFuQjtBQUNJLHdDQUFZLEtBQUssT0FBTCxDQUFhLGNBRDdCLEVBQzZDLFVBQVUsS0FBSyxPQUFMLENBQWEsWUFEcEU7QUFFSSx3Q0FBVyxLQUZmLEVBRXFCLE1BQU0sS0FBSyxPQUFMLENBQWEsU0FGeEM7QUFFb0Q7QUFGcEQscUJBREo7QUFJSSxrREFBTSxJQUFJLE1BQVYsRUFBa0IsSUFBSSxNQUF0QixFQUE4QixJQUFJLENBQWxDLEVBQXFDLElBQUksQ0FBekM7QUFDSSxnQ0FBUSxLQUFLLE9BQUwsQ0FBYSxRQUR6QixFQUNtQyxhQUFhLEtBQUssT0FBTCxDQUFhLFNBRDdEO0FBSkosaUJBREo7QUFTSCxhQXZCQTtBQURMLFNBREo7QUE0Qkg7QUE3RnlCLENBQWxCLENBQVo7O0FBZ0dBLElBQUksWUFBWSxNQUFNLFdBQU4sQ0FBa0I7QUFBQTs7O0FBK0I5Qix1QkFBbUI7QUFDZixxQkFBYyxNQUFNLFNBQU4sQ0FBZ0IsS0FEZjtBQUVmLHFCQUFjLE1BQU0sU0FBTixDQUFnQixNQUZmO0FBR2Ysc0JBQWMsTUFBTSxTQUFOLENBQWdCLE1BSGY7QUFJZixtQkFBYyxNQUFNLFNBQU4sQ0FBZ0IsTUFKZjs7QUFNZixrQkFBZ0IsTUFBTSxTQUFOLENBQWdCLE1BTmpCO0FBT2Ysd0JBQWdCLE1BQU0sU0FBTixDQUFnQixNQVBqQjs7QUFTZixtQkFBZ0IsTUFBTSxTQUFOLENBQWdCLE1BVGpCO0FBVWYsc0JBQWdCLE1BQU0sU0FBTixDQUFnQixNQVZqQjtBQVdmLHdCQUFnQixNQUFNLFNBQU4sQ0FBZ0I7QUFYakIsS0EvQlc7O0FBNkM5QixtQkE3QzhCLDZCQTZDWjtBQUNkLGVBQU87QUFDSDtBQUNBLHNCQUFtQixLQUZoQjtBQUdILDJCQUFtQixDQUhoQjtBQUlILDhCQUFtQixPQUFPLEVBQVAsR0FBWSxFQUFaLEdBQWlCLEVBSmpDO0FBS0gsK0JBQW1CLElBTGhCO0FBTUgsNkJBQW1CLElBTmhCOztBQVFIO0FBQ0EsbUJBQVMsR0FUTjtBQVVILG9CQUFTLEdBVk47QUFXSCxxQkFBUyxFQVhOOztBQWFGO0FBQ0QseUJBQWMsQ0FkWDtBQWVILHVCQUFjLENBZlg7QUFnQkgsMEJBQWMsU0FoQlg7O0FBa0JILHNCQUFpQixNQWxCZDtBQW1CSCw0QkFBaUIsRUFuQmQ7O0FBcUJILHVCQUFnQixNQXJCYjtBQXNCSCwwQkFBZ0IsRUF0QmI7QUF1QkgsNEJBQWdCO0FBdkJiLFNBQVA7QUF5QkgsS0F2RTZCO0FBeUU5QixtQkF6RThCLDZCQXlFWjtBQUNkLGVBQU87QUFDSCx5QkFBZ0IsS0FBSyxLQUFMLENBQVcsV0FEeEI7QUFFSCx5QkFBZ0IsS0FBSyxLQUFMLENBQVcsV0FGeEI7QUFHSCwwQkFBZ0IsS0FBSyxLQUFMLENBQVcsWUFIeEI7QUFJSCx1QkFBZ0IsS0FBSyxLQUFMLENBQVcsU0FKeEI7QUFLSCxzQkFBZ0IsS0FBSyxLQUFMLENBQVcsUUFMeEI7QUFNSCw0QkFBZ0IsS0FBSyxLQUFMLENBQVcsY0FOeEI7QUFPSCx1QkFBZ0IsS0FBSyxLQUFMLENBQVcsU0FQeEI7QUFRSCwwQkFBZ0IsS0FBSyxLQUFMLENBQVcsWUFSeEI7QUFTSCw0QkFBZ0IsS0FBSyxLQUFMLENBQVc7QUFUeEIsU0FBUDtBQVdILEtBckY2QjtBQXVGOUIsbUJBdkY4Qiw2QkF1Rlo7QUFDZCxlQUFPLEtBQUssaUJBQUwsQ0FBdUIsS0FBSyxLQUE1QixDQUFQO0FBQ0gsS0F6RjZCO0FBMkY5Qiw2QkEzRjhCLHFDQTJGSixTQTNGSSxFQTJGTztBQUNqQyxhQUFLLFFBQUwsQ0FBYyxLQUFLLGlCQUFMLENBQXVCLFNBQXZCLENBQWQ7QUFDSCxLQTdGNkI7QUErRjlCLHFCQS9GOEIsNkJBK0ZaLEtBL0ZZLEVBK0ZMO0FBQ3JCLFlBQUksUUFBZSxNQUFNLEtBQXpCO0FBQ0EsWUFBSSxTQUFlLE1BQU0sTUFBekI7QUFDQSxZQUFJLFVBQWUsTUFBTSxPQUF6QjtBQUNBLFlBQUksU0FBZSxNQUFNLE1BQXpCO0FBQ0EsWUFBSSxXQUFlLE1BQU0sUUFBekI7QUFDQSxZQUFJLGVBQWUsTUFBTSxZQUF6QjtBQUNBLFlBQUksY0FBZSxNQUFNLFdBQXpCOztBQUVBO0FBQ0EsWUFBSSxVQUFXLElBQWY7QUFDQSxZQUFJLFVBQVcsSUFBZjtBQUNBLFlBQUksV0FBVyxJQUFmO0FBQ0EsWUFBSSxXQUFXLElBQWY7O0FBRUEsaUJBQVMsT0FBTyxHQUFQLENBQVcsVUFBUyxJQUFULEVBQWUsQ0FBZixFQUFrQjtBQUNsQztBQUNBLGdCQUFJLE9BQVEsSUFBSSxJQUFKLENBQVMsS0FBSyxJQUFkLENBQUQsQ0FBc0IsT0FBdEIsRUFBWDtBQUNBLHNCQUFXLFFBQVEsT0FBUixJQUFrQixLQUFLLEdBQUwsQ0FBUyxPQUFULEVBQWtCLElBQWxCLENBQWxCLEdBQTRDLElBQXZEO0FBQ0Esc0JBQVcsUUFBUSxPQUFSLElBQWtCLEtBQUssR0FBTCxDQUFTLE9BQVQsRUFBa0IsSUFBbEIsQ0FBbEIsR0FBNEMsSUFBdkQ7O0FBRUE7QUFDQSxnQkFBSSxTQUFTLEtBQUssTUFBbEI7QUFDQSxtQkFBTyxPQUFQLENBQWUsVUFBUyxLQUFULEVBQWdCO0FBQzNCLG9CQUFJLFFBQVEsTUFBTSxLQUFsQjtBQUNBLDJCQUFXLFFBQVEsUUFBUixJQUFtQixLQUFLLEdBQUwsQ0FBUyxRQUFULEVBQW1CLEtBQW5CLENBQW5CLEdBQStDLEtBQTFEO0FBQ0EsMkJBQVcsUUFBUSxRQUFSLElBQW1CLEtBQUssR0FBTCxDQUFTLFFBQVQsRUFBbUIsS0FBbkIsQ0FBbkIsR0FBK0MsS0FBMUQ7QUFDSCxhQUpEOztBQU1BLG1CQUFPO0FBQ0gsMEJBREc7QUFFSDtBQUZHLGFBQVA7QUFJSCxTQWxCUSxDQUFUOztBQW9CQTtBQUNBLGVBQU8sSUFBUCxDQUFZLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUN2QixtQkFBTyxFQUFFLElBQUYsR0FBUyxFQUFFLElBQWxCO0FBQ0gsU0FGRDs7QUFJQTtBQUNBLFlBQUksT0FBTyxRQUFQLElBQW1CLFdBQW5CLElBQWtDLFdBQVcsUUFBakQsRUFBMkQ7QUFDdkQsdUJBQVcsUUFBWDtBQUNIOztBQUVEO0FBQ0EsWUFBSSxNQUFNLFFBQVYsRUFBb0I7QUFDaEIsZ0JBQUksb0JBQW9CLE1BQU0saUJBQTlCO0FBQ0EsZ0JBQUksa0JBQW9CLE1BQU0sZUFBOUI7QUFDQSxnQkFBSSxtQkFBb0IsTUFBTSxnQkFBOUI7QUFDQSxnQkFBSSxnQkFBb0IsTUFBTSxhQUE5Qjs7QUFFQTtBQUNBLGdCQUFJLFFBQVEsaUJBQVIsQ0FBSixFQUFnQztBQUM1QixvQ0FBb0IsSUFBSSxJQUFKLENBQVMsaUJBQVQsRUFBNEIsT0FBNUIsRUFBcEI7QUFDSDtBQUNELGdCQUFJLFFBQVEsZUFBUixDQUFKLEVBQThCO0FBQzFCLGtDQUFrQixJQUFJLElBQUosQ0FBUyxlQUFULEVBQTBCLE9BQTFCLEVBQWxCO0FBQ0g7QUFDRDtBQUNBLHNCQUFVLFFBQVEsaUJBQVIsSUFBNEIsaUJBQTVCLEdBQWdELE9BQTFEO0FBQ0Esc0JBQVUsUUFBUSxlQUFSLElBQTBCLGVBQTFCLEdBQTRDLE9BQXREOztBQUVBO0FBQ0EsZ0JBQUksZUFBZSxRQUFRLGVBQVIsSUFBMEIsT0FBMUIsR0FBb0MsVUFBVSxnQkFBakU7O0FBRUE7QUFDQSx1QkFBVyxLQUFLLEdBQUwsQ0FBUyxRQUFULEVBQW1CLGFBQW5CLENBQVg7QUFDQSx1QkFBVyxLQUFLLEdBQUwsQ0FBUyxRQUFULEVBQW1CLGFBQW5CLENBQVg7O0FBRUE7QUFDQSxnQkFBSSxZQUFZLEVBQWhCO0FBQ0EsaUJBQUssSUFBSSxJQUFJLE9BQWIsRUFBc0IsSUFBSSxZQUExQixFQUF3QyxLQUFLLGdCQUE3QyxFQUErRDtBQUMzRCwwQkFBVSxJQUFWLENBQWUsQ0FBZjtBQUNIOztBQUVEO0FBQ0EsZ0JBQUksY0FBYyxDQUFsQjs7QUFFQSxxQkFBUyxVQUFVLEdBQVYsQ0FBYyxVQUFTLElBQVQsRUFBZSxDQUFmLEVBQWtCO0FBQ3JDLG9CQUFJLE9BQU8sT0FBTyxXQUFQLENBQVg7O0FBRUEsb0JBQUksUUFBUSxJQUFSLEtBQWtCLEtBQUssSUFBTCxJQUFhLElBQW5DLEVBQTBDO0FBQ3RDO0FBQ0EsMkJBQU8sSUFBUDtBQUNILGlCQUhELE1BR087QUFDSDtBQUNBLDJCQUFPO0FBQ0gsOEJBQU0sSUFESDtBQUVILGdDQUFRLFlBQVksR0FBWixDQUFnQixVQUFTLEtBQVQsRUFBZ0IsQ0FBaEIsRUFBbUI7QUFDdkMsbUNBQU87QUFDSCx1Q0FBTyxNQUFNLEtBQU4sSUFBZSxDQURuQjtBQUVILHVDQUFPLGFBRko7QUFHSCx1Q0FBTyxNQUFNLEtBQU4sSUFBZTtBQUhuQiw2QkFBUDtBQUtILHlCQU5PO0FBRkwscUJBQVA7QUFVSDtBQUNKLGFBbkJRLENBQVQ7QUFvQkg7O0FBRUQsWUFBSSxZQUFZLFFBQWhCLEVBQTBCO0FBQ3RCLHVCQUFXLFdBQVcsQ0FBdEI7QUFDSDs7QUFFRDtBQUNBLFlBQUksYUFBYSxNQUFNLFlBQU4sR0FBcUIsQ0FBdEM7QUFDQSxZQUFJLFlBQWEsU0FBUyxPQUFULENBQWlCLENBQWpCLEVBQW9CLE1BQXBCLEdBQTZCLE1BQU0sWUFBbkMsR0FBa0QsR0FBbEQsR0FBd0QsTUFBTSxjQUEvRTs7QUFFQSxZQUFJLGFBQWEsUUFBUSxJQUFFLE9BQVYsR0FBb0IsU0FBckM7QUFDQSxZQUFJLGFBQWEsU0FBUyxJQUFFLE9BQVgsR0FBcUIsVUFBdEM7O0FBRUE7QUFDQSxZQUFJLFNBQVMsWUFBWSxPQUF6QjtBQUNBLFlBQUksU0FBUyxVQUFVLGFBQWEsT0FBdkIsQ0FBYjs7QUFFQSxZQUFJLFFBQVEsT0FBWjtBQUNBLFlBQUksT0FBUSxTQUFTLE9BQXJCOztBQUVBLGVBQU87QUFDSCx3QkFERztBQUVILDBCQUZHO0FBR0gsMEJBSEc7QUFJSCw0QkFKRztBQUtILDRCQUxHO0FBTUgsOEJBTkc7QUFPSCw4QkFQRztBQVFILGtDQVJHO0FBU0gsa0NBVEc7QUFVSCwwQkFWRztBQVdILDBCQVhHO0FBWUgsc0JBWkc7QUFhSDtBQWJHLFNBQVA7QUFlSCxLQXJPNkI7QUF1TzlCLFVBdk84QixvQkF1T3JCO0FBQ0wsWUFBSSxRQUFhLEtBQUssS0FBTCxDQUFXLEtBQTVCO0FBQ0EsWUFBSSxTQUFhLEtBQUssS0FBTCxDQUFXLE1BQTVCO0FBQ0EsWUFBSSxTQUFhLEtBQUssS0FBTCxDQUFXLE1BQTVCO0FBQ0EsWUFBSSxVQUFhLEtBQUssS0FBTCxDQUFXLE9BQTVCO0FBQ0EsWUFBSSxVQUFhLEtBQUssS0FBTCxDQUFXLE9BQTVCO0FBQ0EsWUFBSSxXQUFhLEtBQUssS0FBTCxDQUFXLFFBQTVCO0FBQ0EsWUFBSSxXQUFhLEtBQUssS0FBTCxDQUFXLFFBQTVCO0FBQ0EsWUFBSSxhQUFhLEtBQUssS0FBTCxDQUFXLFVBQTVCO0FBQ0EsWUFBSSxhQUFhLEtBQUssS0FBTCxDQUFXLFVBQTVCO0FBQ0EsWUFBSSxTQUFhLEtBQUssS0FBTCxDQUFXLE1BQTVCO0FBQ0EsWUFBSSxTQUFhLEtBQUssS0FBTCxDQUFXLE1BQTVCO0FBQ0EsWUFBSSxPQUFhLEtBQUssS0FBTCxDQUFXLElBQTVCO0FBQ0EsWUFBSSxRQUFhLEtBQUssS0FBTCxDQUFXLEtBQTVCOztBQUVBLGVBQ0k7QUFBQTtBQUFBLGNBQUssV0FBVSxZQUFmLEVBQTRCLE9BQU8sS0FBbkMsRUFBMEMsUUFBUSxNQUFsRCxFQUEwRCxTQUFTLFNBQU8sS0FBUCxHQUFhLEdBQWIsR0FBaUIsTUFBcEYsRUFBNEYscUJBQW9CLGVBQWhIO0FBQ0ksZ0NBQUMsS0FBRCxJQUFPLFFBQVEsVUFBZjtBQUNJLHlCQUFTLE9BRGI7QUFFSSx5QkFBUyxPQUZiO0FBR0ksd0JBQVEsTUFIWjtBQUlJLHNCQUFNLElBSlYsR0FESjtBQU1JLGdDQUFDLEtBQUQsSUFBTyxRQUFRLFVBQWY7QUFDSSwwQkFBVSxRQURkO0FBRUksMEJBQVUsUUFGZDtBQUdJLHdCQUFRLE1BSFo7QUFJSSx3QkFBUSxNQUpaO0FBS0ksdUJBQU8sS0FMWCxHQU5KO0FBWUksZ0NBQUMsSUFBRCxJQUFNLFFBQVEsTUFBZDtBQUNJLHlCQUFTLE9BRGI7QUFFSSx5QkFBUyxPQUZiO0FBR0ksMEJBQVUsUUFIZDtBQUlJLDBCQUFVLFFBSmQ7QUFLSSx1QkFBTyxVQUxYO0FBTUksd0JBQVEsVUFOWjtBQU9JLHdCQUFRLE1BUFo7QUFRSSx3QkFBUSxNQVJaO0FBU0ksdUJBQU8sS0FUWDtBQVpKLFNBREo7QUF5Qkg7QUEvUTZCLENBQWxCLENBQWhCOztBQWtSQSxPQUFPLE9BQVAsR0FBaUIsU0FBakIiLCJmaWxlIjoiVGltZUdyYXBoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUmVhY3QgID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG5jb25zdCBUaW1lTGluZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgY3VycmVudFg6ICAgUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgbGluZVRvcDogICAgUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgbGluZUJvdHRvbTogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgbGFzdFg6ICAgICAgUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgbGFzdFBvaW50czogUmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBwb2ludHM6ICAgICBSZWFjdC5Qcm9wVHlwZXMuYXJyYXlcbiAgICB9LFxuXG4gICAgY29udGV4dFR5cGVzOiB7XG4gICAgICAgIHBvaW50UmFkaXVzOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBsaW5lV2lkdGg6ICAgUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgYXhlQ29sb3I6ICAgIFJlYWN0LlByb3BUeXBlcy5zdHJpbmdcbiAgICB9LFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG92ZXI6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHNldEhvdmVyKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaG92ZXI6IHN0YXRlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZW5kZXJQYXRoTGluZShpbmRleCkge1xuICAgICAgICB2YXIgbGFzdFggPSB0aGlzLnByb3BzLmxhc3RYO1xuICAgICAgICBpZiAoIUJvb2xlYW4obGFzdFgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyZW50WCAgICAgPSB0aGlzLnByb3BzLmN1cnJlbnRYO1xuICAgICAgICB2YXIgY3VycmVudFBvaW50ID0gdGhpcy5wcm9wcy5wb2ludHNbaW5kZXhdO1xuICAgICAgICB2YXIgbGFzdFBvaW50ICAgID0gdGhpcy5wcm9wcy5sYXN0UG9pbnRzW2luZGV4XTtcblxuICAgICAgICByZXR1cm4gPGxpbmUgeDE9e2xhc3RYfSB5MT17bGFzdFBvaW50Lnl9IHgyPXtjdXJyZW50WH0geTI9e2N1cnJlbnRQb2ludC55fVxuICAgICAgICAgICAgc3Ryb2tlPXtjdXJyZW50UG9pbnQuY29sb3J9IHN0cm9rZVdpZHRoPXt0aGlzLmNvbnRleHQubGluZVdpZHRofSAvPjtcbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgdGhhdCAgICAgICA9IHRoaXM7XG4gICAgICAgIHZhciBjdXJyZW50WCAgID0gdGhpcy5wcm9wcy5jdXJyZW50WDtcbiAgICAgICAgdmFyIGxpbmVUb3AgICAgPSB0aGlzLnByb3BzLmxpbmVUb3A7XG4gICAgICAgIHZhciBsaW5lQm90dG9tID0gdGhpcy5wcm9wcy5saW5lQm90dG9tO1xuICAgICAgICB2YXIgcG9pbnRzICAgICA9IHRoaXMucHJvcHMucG9pbnRzO1xuXG4gICAgICAgIHZhciBob3ZlciA9IHRoaXMuc3RhdGUuaG92ZXI7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxnPlxuICAgICAgICAgICAgICAgIDxsaW5lIHgxPXtjdXJyZW50WH0geDI9e2N1cnJlbnRYfSB5MT17bGluZVRvcH0geTI9e2xpbmVCb3R0b219XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZT17dGhpcy5jb250ZXh0LmF4ZUNvbG9yfSBzdHJva2VXaWR0aD17dGhpcy5jb250ZXh0LmxpbmVXaWR0aH0gLz5cblxuICAgICAgICAgICAgICAgIHtwb2ludHMubWFwKGZ1bmN0aW9uKHBvaW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgICAgICA9IHBvaW50LmNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHNlcmllIG5hbWUgdG8gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFTZXJpZSAgPSBwb2ludC5zZXJpZSB8fCBpbmRleDtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGcga2V5PXtpbmRleH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoYXQucmVuZGVyUGF0aExpbmUoaW5kZXgpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXsnc2VyaWUtcG9pbnQnKyhob3Zlcj8gJyBob3ZlcicgOiAnJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17dGhhdC5zZXRIb3Zlci5iaW5kKHRoYXQsIHRydWUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9e3RoYXQuc2V0SG92ZXIuYmluZCh0aGF0LCBmYWxzZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI9e3RoYXQuY29udGV4dC5wb2ludFJhZGl1c31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD17Y29sb3J9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXt0aGF0LmNvbnRleHQubGluZVdpZHRoICogMn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiI0ZGRkZGRlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4PXtjdXJyZW50WH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3k9e3BvaW50Lnl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtdmFsdWU9e3BvaW50LnZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXRpbWVzdGFtcD17TnVtYmVyKHBvaW50LmRhdGUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXNlcmllPXtkYXRhU2VyaWV9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgPC9nPlxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG52YXIgQm9keSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgZGF0ZU1pbjogICBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBkYXRlTWF4OiAgIFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIHZhbHVlTWluOiAgUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgdmFsdWVNYXg6ICBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICB3aWR0aDogICAgIFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGhlaWdodDogICAgUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgaW5uZXJYOiAgICBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBpbm5lclk6ICAgIFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIHlCYXNlOiAgICAgUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgc2VyaWVzOiAgICBSZWFjdC5Qcm9wVHlwZXMuYXJyYXlcbiAgICB9LFxuXG4gICAgY29udGV4dFR5cGVzOiB7XG4gICAgICAgIHNlcmllc1N0eWxlOiAgUmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBwb2ludFJhZGl1czogIFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGRlZmF1bHRDb2xvcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgbGluZVdpZHRoOiAgICBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBheGVDb2xvcjogICAgIFJlYWN0LlByb3BUeXBlcy5zdHJpbmdcbiAgICB9LFxuXG4gICAgLy8gQ29tcHV0ZSBYIGZvciBhIHBvaW50IGluc2lkZSBCb2R5XG4gICAgaW5uZXJQb3NpdGlvblgocFgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuaW5uZXJYICsgcFgqdGhpcy5wcm9wcy53aWR0aDtcbiAgICB9LFxuXG4gICAgLy8gQ29tcHV0ZSBZIGZvciBhIHBvaW50IGluc2lkZSBCb2R5XG4gICAgaW5uZXJQb3NpdGlvblkocFkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMueUJhc2UgKyAodGhpcy5wcm9wcy5oZWlnaHQgKiAoMSAtIHBZKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBpbm5lciBYIHZhbHVlIGZvciBhIGRhdGVcbiAgICBnZXRJbm5lclgoZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbm5lclBvc2l0aW9uWCgoZGF0ZSAtIHRoaXMucHJvcHMuZGF0ZU1pbikvKHRoaXMucHJvcHMuZGF0ZU1heCAtIHRoaXMucHJvcHMuZGF0ZU1pbikpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gaW5uZXIgWSB2YWx1ZSBmb3IgYSB2YWx1ZVxuICAgIGdldElubmVyWSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbm5lclBvc2l0aW9uWSgodmFsdWUgLSB0aGlzLnByb3BzLnZhbHVlTWluKS8odGhpcy5wcm9wcy52YWx1ZU1heCAtIHRoaXMucHJvcHMudmFsdWVNaW4pKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGNvcnJlY3QgbWFwcGluZyBmb3IgYSBwb2ludCB0byBkcmF3IGluIFRpbWVMaW5lXG4gICAgZm9ybWF0UG9pbnQodGltZSwgcG9pbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBzZXJpZXNTdHlsZSA9IHRoaXMuY29udGV4dC5zZXJpZXNTdHlsZTtcbiAgICAgICAgdmFyIHNlcmllU3R5bGUgPSBzZXJpZXNTdHlsZVtpbmRleF07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbG9yOiBwb2ludC5jb2xvciB8fCAoc2VyaWVTdHlsZT8gc2VyaWVTdHlsZS5jb2xvciA6IG51bGwpIHx8IHRoaXMuY29udGV4dC5kZWZhdWx0Q29sb3IsXG4gICAgICAgICAgICB2YWx1ZTogcG9pbnQudmFsdWUsXG4gICAgICAgICAgICBzZXJpZTogcG9pbnQuc2VyaWUgfHwgKHNlcmllU3R5bGU/IHNlcmllU3R5bGUudGl0bGUgOiBpbmRleCksXG4gICAgICAgICAgICBkYXRlOiAgdGltZS5kYXRlLFxuICAgICAgICAgICAgeTogICAgIHRoaXMuZ2V0SW5uZXJZKHBvaW50LnZhbHVlKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBEcmF3IHRoaXMgdGltZSBsaW5lXG4gICAgZHJhd1RpbWVMaW5lKHRpbWUsIGksIHNlcmllcykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgLy8gQ3VycmVudCB0aW1lIGluZm9ybWF0aW9uc1xuICAgICAgICB2YXIgY3VycmVudFggICA9IHRoYXQuZ2V0SW5uZXJYKHRpbWUuZGF0ZSk7XG4gICAgICAgIHZhciBsaW5lVG9wICAgID0gdGhhdC5wcm9wcy55QmFzZTtcbiAgICAgICAgdmFyIGxpbmVCb3R0b20gPSB0aGF0LnByb3BzLnlCYXNlICsgdGhhdC5wcm9wcy5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRpbWUucG9pbnRzLm1hcCh0aGF0LmZvcm1hdFBvaW50LmJpbmQodGhhdCwgdGltZSkpO1xuXG4gICAgICAgIC8vIExhc3QgdGltZSBpbmZvcm1hdGlvbnNcbiAgICAgICAgdmFyIGxhc3RYICAgICAgPSBudWxsO1xuICAgICAgICB2YXIgbGFzdFBvaW50cyA9IG51bGw7XG4gICAgICAgIHZhciBsYXN0VGltZSAgID0gc2VyaWVzW2kgLSAxXTtcblxuICAgICAgICBpZiAoQm9vbGVhbihsYXN0VGltZSkpIHtcbiAgICAgICAgICAgIGxhc3RYICAgICAgPSB0aGF0LmdldElubmVyWChsYXN0VGltZS5kYXRlKTtcbiAgICAgICAgICAgIGxhc3RQb2ludHMgPSBsYXN0VGltZS5wb2ludHMubWFwKHRoYXQuZm9ybWF0UG9pbnQuYmluZCh0aGF0LCBsYXN0VGltZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxUaW1lTGluZSBrZXk9e2l9XG4gICAgICAgICAgICAgICAgY3VycmVudFg9e2N1cnJlbnRYfVxuICAgICAgICAgICAgICAgIGxpbmVUb3A9e2xpbmVUb3B9XG4gICAgICAgICAgICAgICAgbGluZUJvdHRvbT17bGluZUJvdHRvbX1cbiAgICAgICAgICAgICAgICBwb2ludHM9e3BvaW50c31cbiAgICAgICAgICAgICAgICBsYXN0WD17bGFzdFh9XG4gICAgICAgICAgICAgICAgbGFzdFBvaW50cz17bGFzdFBvaW50c30gLz5cbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgc2VyaWVzID0gdGhpcy5wcm9wcy5zZXJpZXM7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxnPlxuICAgICAgICAgICAge3Nlcmllcy5tYXAodGhpcy5kcmF3VGltZUxpbmUsIHRoaXMpfVxuICAgICAgICAgICAgPC9nPlxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG52YXIgWEF4aXMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGxlbmd0aDogIFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGRhdGVNaW46IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGRhdGVNYXg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGlubmVyWDogIFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIHlUb3A6ICAgIFJlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgICB9LFxuXG4gICAgY29udGV4dFR5cGVzOiB7XG4gICAgICAgIHRleHRDb2xvcjogICAgICBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICB0ZXh0Rm9udFNpemU6ICAgUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgdGV4dEZvbnRGYW1pbHk6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmdcbiAgICB9LFxuXG4gICAgZ2V0VmFsdWVQZXJJbnRlcnZhbCgpIHtcbiAgICAgICAgdmFyIGRhdGVNaW4gPSB0aGlzLnByb3BzLmRhdGVNaW47XG4gICAgICAgIHZhciBkYXRlTWF4ID0gdGhpcy5wcm9wcy5kYXRlTWF4O1xuXG4gICAgICAgIC8vIEdldCBvcHRpbWFsIGludGVydmFsIGZvciBYIGF4aXNcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdTU1NTJyxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbDogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdTU1NTJyxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbDogMTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnU1NTUycsXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IDEwMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbDogMSoxMDAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ0g6bW0nLFxuICAgICAgICAgICAgICAgIGludGVydmFsOiA2MCoxMDAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ0gnLFxuICAgICAgICAgICAgICAgIGludGVydmFsOiA2MCo2MCoxMDAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ0REL01NJyxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbDogMSoyNCo2MCo2MCoxMDAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ0REL01NJyxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbDogNyoyNCo2MCo2MCoxMDAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ0REL01NJyxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbDogMzAqMjQqNjAqNjAqMTAwMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdZWVlZJyxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbDogMzY1KjI0KjYwKjYwKjEwMDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnWVlZWScsXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IDEwKjM2NSoyNCo2MCo2MCoxMDAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ1lZWVknLFxuICAgICAgICAgICAgICAgIGludGVydmFsOiAxMDAqMzY1KjI0KjYwKjYwKjEwMDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgXS5maWx0ZXIoZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IChkYXRlTWF4IC0gZGF0ZU1pbikvaW50ZXJ2YWwuaW50ZXJ2YWw7XG4gICAgICAgICAgICByZXR1cm4gY291bnQgPiAxO1xuICAgICAgICB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uKGludGVydmFsKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAoZGF0ZU1heCAtIGRhdGVNaW4pL2ludGVydmFsLmludGVydmFsO1xuICAgICAgICAgICAgcmV0dXJuIHsgY291bnQsIGludGVydmFsIH07XG4gICAgICAgIH0pXG4gICAgICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmNvdW50ID4gYi5jb3VudDtcbiAgICAgICAgfSlbMF0uaW50ZXJ2YWw7XG4gICAgfSxcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHRoYXQgICAgPSB0aGlzO1xuICAgICAgICB2YXIgZGF0ZU1pbiA9IHRoaXMucHJvcHMuZGF0ZU1pbjtcbiAgICAgICAgdmFyIGRhdGVNYXggPSB0aGlzLnByb3BzLmRhdGVNYXg7XG4gICAgICAgIHZhciBsZW5ndGggID0gdGhpcy5wcm9wcy5sZW5ndGg7XG4gICAgICAgIHZhciBpbm5lclggID0gdGhpcy5wcm9wcy5pbm5lclg7XG4gICAgICAgIHZhciB5VG9wICAgID0gdGhpcy5wcm9wcy55VG9wO1xuXG4gICAgICAgIC8vIENvbXB1dGUgaW50ZXJ2YWxzIGZvciByZW5kZXJpbmcgZGF0ZXNcbiAgICAgICAgdmFyIHZhbHVlUGVySW50ZXJ2YWwgPSB0aGlzLmdldFZhbHVlUGVySW50ZXJ2YWwoKTtcbiAgICAgICAgdmFyIHdQZXJNUyAgICAgICAgICAgPSBsZW5ndGgvKGRhdGVNYXggLSBkYXRlTWluKTtcbiAgICAgICAgdmFyIGF4ZVhJbnRlcnZhbCAgICAgPSAoKGRhdGVNYXggLSBkYXRlTWluKSAqIHdQZXJNUykgLyAodGhpcy5jb250ZXh0LnRleHRGb250U2l6ZSAqIDEwKTtcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgcmFuZ2Ugb2YgaW50ZXJ2YWxzXG4gICAgICAgIHZhciBpbnRlcnZhbFJhbmdlID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlWEludGVydmFsOyBpKyspIHtcbiAgICAgICAgICAgIGludGVydmFsUmFuZ2UucHVzaChpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8Zz5cbiAgICAgICAgICAgIHtpbnRlcnZhbFJhbmdlLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaSAqIHZhbHVlUGVySW50ZXJ2YWwuaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgID0gbmV3IERhdGUoZGF0ZU1pbiArIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIHZhciB4ID0gaW5uZXJYICsgKHZhbHVlICogd1Blck1TKTtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBkcmF3IHBvaW50IGlmIHRvbyBmYXJcbiAgICAgICAgICAgICAgICBpZiAoeCA+IGlubmVyWCArIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gPHRleHQga2V5PXtpfSB4PXt4fSB5PXt5VG9wfVxuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5PXt0aGF0LmNvbnRleHQudGV4dEZvbnRGYW1pbHl9IGZvbnRTaXplPXt0aGF0LmNvbnRleHQudGV4dEZvbnRTaXplfVxuICAgICAgICAgICAgICAgICAgICBmaWxsPXt0aGF0LmNvbnRleHQudGV4dENvbG9yfSB0ZXh0QW5jaG9yPVwibWlkZGxlXCI+e21vbWVudChkYXRlKS5mb3JtYXQodmFsdWVQZXJJbnRlcnZhbC5mb3JtYXQpfTwvdGV4dD47XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICAgIDwvZz5cbiAgICAgICAgKTtcbiAgICB9XG59KTtcblxudmFyIFlBeGlzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgIHByb3BUeXBlczoge1xuICAgICAgICBsZW5ndGg6ICAgICAgIFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIHZhbHVlTWluOiAgICAgUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgdmFsdWVNYXg6ICAgICBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBpbm5lclg6ICAgICAgIFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGlubmVyWTogICAgICAgUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgeUJhc2U6ICAgICAgICBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBheGVZSW50ZXJ2YWw6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgICB9LFxuXG4gICAgLy8gQ29tcHV0ZXMgdGhlIG9wdGltYWwgdGljayBzdGVwIGZvciB0aGUgWSBheGlzXG4gICAgLy8gV2UgYXNzdW1lOiByYW5nZSA9IE1hdGguYWJzKHVwcGVyIC0gbG93ZXIpXG4gICAgLy8gaS5lOiByYW5nZSBzaG91bGQgbm90IGJlIG5lZ2F0aXZlXG4gICAgb3B0aW1hbFRpY2tTdGVwKG1heFRpY2tzKSB7XG4gICAgICAgIHZhciB2YWx1ZU1pbiA9IHRoaXMucHJvcHMudmFsdWVNaW47XG4gICAgICAgIHZhciB2YWx1ZU1heCA9IHRoaXMucHJvcHMudmFsdWVNYXg7XG5cbiAgICAgICAgdmFyIHJhbmdlICAgICA9IHZhbHVlTWF4IC0gdmFsdWVNaW47XG4gICAgICAgIHZhciBtaW5pbXVtICAgPSByYW5nZSAvIG1heFRpY2tzO1xuICAgICAgICB2YXIgbWFnbml0dWRlID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2cobWluaW11bSkgLyBNYXRoLmxvZygxMCkpKTtcbiAgICAgICAgdmFyIHJlc2lkdWFsICA9IG1pbmltdW0gLyBtYWduaXR1ZGU7XG5cbiAgICAgICAgLy8gVGljayBpcyBhbiBhbXBsaWZpZWQgbWFnbml0dWRlXG4gICAgICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgcmVzaWR1YWxcbiAgICAgICAgaWYgKHJlc2lkdWFsID4gNSkge1xuICAgICAgICAgICAgcmV0dXJuIDEwICogbWFnbml0dWRlO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc2lkdWFsID4gMikge1xuICAgICAgICAgICAgcmV0dXJuIDUgKiBtYWduaXR1ZGU7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzaWR1YWwgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMiAqIG1hZ25pdHVkZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFnbml0dWRlO1xuICAgIH0sXG5cbiAgICBjb250ZXh0VHlwZXM6IHtcbiAgICAgICAgbGluZVdpZHRoOiAgICAgIFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGF4ZUNvbG9yOiAgICAgICBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBheGVNYXJrZXJXaWR0aDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgdGV4dENvbG9yOiAgICAgIFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHRleHRGb250U2l6ZTogICBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICB0ZXh0Rm9udEZhbWlseTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB0aGF0ICAgICAgICAgPSB0aGlzO1xuICAgICAgICB2YXIgdmFsdWVNaW4gICAgID0gdGhpcy5wcm9wcy52YWx1ZU1pbjtcbiAgICAgICAgdmFyIHZhbHVlTWF4ICAgICA9IHRoaXMucHJvcHMudmFsdWVNYXg7XG4gICAgICAgIHZhciBsZW5ndGggICAgICAgPSB0aGlzLnByb3BzLmxlbmd0aDtcbiAgICAgICAgdmFyIGF4ZVlJbnRlcnZhbCA9IHRoaXMucHJvcHMuYXhlWUludGVydmFsO1xuICAgICAgICB2YXIgaW5uZXJYICAgICAgID0gdGhpcy5wcm9wcy5pbm5lclg7XG4gICAgICAgIHZhciBpbm5lclkgICAgICAgPSB0aGlzLnByb3BzLmlubmVyWTtcbiAgICAgICAgdmFyIHlCYXNlICAgICAgICA9IHRoaXMucHJvcHMueUJhc2U7XG5cbiAgICAgICAgdmFyIGhQZXJWYWx1ZSAgICA9IGxlbmd0aC8odmFsdWVNYXggLSB2YWx1ZU1pbik7XG4gICAgICAgIGF4ZVlJbnRlcnZhbCA9ICgodmFsdWVNYXggLSB2YWx1ZU1pbikgKiBoUGVyVmFsdWUpIC8gKHRoaXMuY29udGV4dC50ZXh0Rm9udFNpemUgKiA0KTtcblxuICAgICAgICAvLyBDYWxjdWwgcGVyZmVjdCB2YWx1ZSBwZXIgaW50ZXJ2YWwgKDEsIDEwLCAxMDAsIDEwMDAsIC4uLilcbiAgICAgICAgdmFyIHZhbHVlUGVySW50ZXJ2YWwgPSB0aGF0Lm9wdGltYWxUaWNrU3RlcChheGVZSW50ZXJ2YWwpO1xuICAgICAgICAvLyBDb25zdHJ1Y3QgcmFuZ2Ugb2YgaW50ZXJ2YWxzXG4gICAgICAgIHZhciBpbnRlcnZhbFJhbmdlID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlWUludGVydmFsKzE7IGkrKykge1xuICAgICAgICAgICAgaW50ZXJ2YWxSYW5nZS5wdXNoKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxnPlxuICAgICAgICAgICAgICAgIHtpbnRlcnZhbFJhbmdlLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSAgICAgICAgPSBpICogdmFsdWVQZXJJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgICAgICAgICAgICA9IGlubmVyWSAtICh2YWx1ZSAqIGhQZXJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXNwbGF5VmFsdWUgPSB2YWx1ZSArIHZhbHVlTWluO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGRyYXcgcG9pbnQgaWYgaXMgdG9vIGhpZ2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPCB5QmFzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dFggID0gaW5uZXJYIC0gKDIqdGhhdC5jb250ZXh0LmF4ZU1hcmtlcldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVYMSA9IGlubmVyWCAtIHRoYXQuY29udGV4dC5heGVNYXJrZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVYMiA9IGlubmVyWDtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGcga2V5PXtpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGV4dCB4PXt0ZXh0WH0geT17eX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udEZhbWlseT17dGhhdC5jb250ZXh0LnRleHRGb250RmFtaWx5fSBmb250U2l6ZT17dGhhdC5jb250ZXh0LnRleHRGb250U2l6ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cImVuZFwiIGZpbGw9e3RoYXQuY29udGV4dC50ZXh0Q29sb3J9PntkaXNwbGF5VmFsdWV9PC90ZXh0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaW5lIHgxPXtsaW5lWDF9IHgyPXtsaW5lWDJ9IHkxPXt5fSB5Mj17eX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPXt0aGF0LmNvbnRleHQuYXhlQ29sb3J9IHN0cm9rZVdpZHRoPXt0aGF0LmNvbnRleHQubGluZVdpZHRofSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgPC9nPlxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG52YXIgVGltZUdyYXBoID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgIHByb3BUeXBlczoge1xuICAgICAgICAvLyBTZXJpZXNcbiAgICAgICAgc2VyaWVzOiAgICAgIFJlYWN0LlByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICAgICAgICBzZXJpZXNTdHlsZTogUmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBtaW5WYWx1ZTogICAgUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcblxuICAgICAgICAvLyBBdXRvZmlsbFxuICAgICAgICBhdXRvRmlsbDogICAgICAgICAgUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGF1dG9GaWxsVmFsdWU6ICAgICBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBhdXRvRmlsbFN0YXJ0VGltZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgYXV0b0ZpbGxFbmRUaW1lOiAgIFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAgICAgLy8gU2l6ZVxuICAgICAgICB3aWR0aDogICBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBoZWlnaHQ6ICBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBwYWRkaW5nOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgICAgIC8vIFN0eWxpbmdcbiAgICAgICAgcG9pbnRSYWRpdXM6ICBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBsaW5lV2lkdGg6ICAgIFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGRlZmF1bHRDb2xvcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcblxuICAgICAgICBheGVDb2xvcjogICAgICAgUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgYXhlTWFya2VyV2lkdGg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAgICAgdGV4dENvbG9yOiAgICAgIFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHRleHRGb250U2l6ZTogICBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICB0ZXh0Rm9udEZhbWlseTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICAgIH0sXG5cbiAgICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgICAgICBzZXJpZXNTdHlsZTogIFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgcG9pbnRSYWRpdXM6ICBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBkZWZhdWx0Q29sb3I6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGxpbmVXaWR0aDogICAgUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcblxuICAgICAgICBheGVDb2xvcjogICAgICAgUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgYXhlTWFya2VyV2lkdGg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAgICAgdGV4dENvbG9yOiAgICAgIFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHRleHRGb250U2l6ZTogICBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICB0ZXh0Rm9udEZhbWlseTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBBdXRvZmlsbFxuICAgICAgICAgICAgYXV0b0ZpbGw6ICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgYXV0b0ZpbGxWYWx1ZTogICAgIDAsXG4gICAgICAgICAgICBhdXRvRmlsbEludGVydmFsOiAgMTAwMCAqIDYwICogNjAgKiAyNCxcbiAgICAgICAgICAgIGF1dG9GaWxsU3RhcnRUaW1lOiBudWxsLFxuICAgICAgICAgICAgYXV0b0ZpbGxFbmRUaW1lOiAgIG51bGwsXG5cbiAgICAgICAgICAgIC8vIFNpemVcbiAgICAgICAgICAgIHdpZHRoOiAgIDgwMCxcbiAgICAgICAgICAgIGhlaWdodDogIDQwMCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDIwLFxuXG4gICAgICAgICAgICAgLy8gU3R5bGluZ1xuICAgICAgICAgICAgcG9pbnRSYWRpdXM6ICA0LFxuICAgICAgICAgICAgbGluZVdpZHRoOiAgICAxLFxuICAgICAgICAgICAgZGVmYXVsdENvbG9yOiAnIzFkYjM0ZicsXG5cbiAgICAgICAgICAgIGF4ZUNvbG9yOiAgICAgICAgJyNlZWUnLFxuICAgICAgICAgICAgYXhlTWFya2VyV2lkdGg6ICAxMCxcblxuICAgICAgICAgICAgdGV4dENvbG9yOiAgICAgICcjYWFhJyxcbiAgICAgICAgICAgIHRleHRGb250U2l6ZTogICAxMCxcbiAgICAgICAgICAgIHRleHRGb250RmFtaWx5OiAnaGVsdmV0aWNhJ1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXJpZXNTdHlsZTogICAgdGhpcy5wcm9wcy5zZXJpZXNTdHlsZSxcbiAgICAgICAgICAgIHBvaW50UmFkaXVzOiAgICB0aGlzLnByb3BzLnBvaW50UmFkaXVzLFxuICAgICAgICAgICAgZGVmYXVsdENvbG9yOiAgIHRoaXMucHJvcHMuZGVmYXVsdENvbG9yLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAgICAgIHRoaXMucHJvcHMubGluZVdpZHRoLFxuICAgICAgICAgICAgYXhlQ29sb3I6ICAgICAgIHRoaXMucHJvcHMuYXhlQ29sb3IsXG4gICAgICAgICAgICBheGVNYXJrZXJXaWR0aDogdGhpcy5wcm9wcy5heGVNYXJrZXJXaWR0aCxcbiAgICAgICAgICAgIHRleHRDb2xvcjogICAgICB0aGlzLnByb3BzLnRleHRDb2xvcixcbiAgICAgICAgICAgIHRleHRGb250U2l6ZTogICB0aGlzLnByb3BzLnRleHRGb250U2l6ZSxcbiAgICAgICAgICAgIHRleHRGb250RmFtaWx5OiB0aGlzLnByb3BzLnRleHRGb250RmFtaWx5XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVGcm9tUHJvcHModGhpcy5wcm9wcyk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5nZXRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMpKTtcbiAgICB9LFxuXG4gICAgZ2V0U3RhdGVGcm9tUHJvcHMocHJvcHMpIHtcbiAgICAgICAgdmFyIHdpZHRoICAgICAgICA9IHByb3BzLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ICAgICAgID0gcHJvcHMuaGVpZ2h0O1xuICAgICAgICB2YXIgcGFkZGluZyAgICAgID0gcHJvcHMucGFkZGluZztcbiAgICAgICAgdmFyIHNlcmllcyAgICAgICA9IHByb3BzLnNlcmllcztcbiAgICAgICAgdmFyIG1pblZhbHVlICAgICA9IHByb3BzLm1pblZhbHVlO1xuICAgICAgICB2YXIgZGVmYXVsdENvbG9yID0gcHJvcHMuZGVmYXVsdENvbG9yO1xuICAgICAgICB2YXIgc2VyaWVzU3R5bGUgID0gcHJvcHMuc2VyaWVzU3R5bGU7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB2YWx1ZXMgcmFuZ2VzXG4gICAgICAgIHZhciBkYXRlTWluICA9IG51bGw7XG4gICAgICAgIHZhciBkYXRlTWF4ICA9IG51bGw7XG4gICAgICAgIHZhciB2YWx1ZU1pbiA9IG51bGw7XG4gICAgICAgIHZhciB2YWx1ZU1heCA9IG51bGw7XG5cbiAgICAgICAgc2VyaWVzID0gc2VyaWVzLm1hcChmdW5jdGlvbih0aW1lLCBpKSB7XG4gICAgICAgICAgICAvLyBTZXQgbWluL21heCBkYXRlc1xuICAgICAgICAgICAgdmFyIGRhdGUgPSAobmV3IERhdGUodGltZS5kYXRlKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgZGF0ZU1pbiAgPSBCb29sZWFuKGRhdGVNaW4pPyBNYXRoLm1pbihkYXRlTWluLCBkYXRlKSA6IGRhdGU7XG4gICAgICAgICAgICBkYXRlTWF4ICA9IEJvb2xlYW4oZGF0ZU1heCk/IE1hdGgubWF4KGRhdGVNYXgsIGRhdGUpIDogZGF0ZTtcblxuICAgICAgICAgICAgLy8gU2V0IG1pbi9tYXggdmFsdWVzXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGltZS5wb2ludHM7XG4gICAgICAgICAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBvaW50LnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhbHVlTWluID0gQm9vbGVhbih2YWx1ZU1pbik/IE1hdGgubWluKHZhbHVlTWluLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB2YWx1ZU1heCA9IEJvb2xlYW4odmFsdWVNYXgpPyBNYXRoLm1heCh2YWx1ZU1heCwgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgICAgIHBvaW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU29ydCBieSBkYXRlXG4gICAgICAgIHNlcmllcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmRhdGUgLSBiLmRhdGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldCBtaW5WYWx1ZSBpZiBzZXRcbiAgICAgICAgaWYgKHR5cGVvZiBtaW5WYWx1ZSAhPSAndW5kZWZpbmVkJyAmJiBtaW5WYWx1ZSA8IHZhbHVlTWluKSB7XG4gICAgICAgICAgICB2YWx1ZU1pbiA9IG1pblZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXV0by1maWxsXG4gICAgICAgIGlmIChwcm9wcy5hdXRvRmlsbCkge1xuICAgICAgICAgICAgdmFyIGF1dG9GaWxsU3RhcnRUaW1lID0gcHJvcHMuYXV0b0ZpbGxTdGFydFRpbWU7XG4gICAgICAgICAgICB2YXIgYXV0b0ZpbGxFbmRUaW1lICAgPSBwcm9wcy5hdXRvRmlsbEVuZFRpbWU7XG4gICAgICAgICAgICB2YXIgYXV0b0ZpbGxJbnRlcnZhbCAgPSBwcm9wcy5hdXRvRmlsbEludGVydmFsO1xuICAgICAgICAgICAgdmFyIGF1dG9GaWxsVmFsdWUgICAgID0gcHJvcHMuYXV0b0ZpbGxWYWx1ZTtcblxuICAgICAgICAgICAgLy8gU2V0IGF1dG9GaWxsIHRpbWVzIHRvIHRpbWVzdGFtcHMgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmIChCb29sZWFuKGF1dG9GaWxsU3RhcnRUaW1lKSkge1xuICAgICAgICAgICAgICAgIGF1dG9GaWxsU3RhcnRUaW1lID0gbmV3IERhdGUoYXV0b0ZpbGxTdGFydFRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCb29sZWFuKGF1dG9GaWxsRW5kVGltZSkpIHtcbiAgICAgICAgICAgICAgICBhdXRvRmlsbEVuZFRpbWUgPSBuZXcgRGF0ZShhdXRvRmlsbEVuZFRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCBzdGFydCBhbmQgZW5kIHRpbWUgZGVwZW5kaW5nIG9uIG9wdGlvbnNcbiAgICAgICAgICAgIGRhdGVNaW4gPSBCb29sZWFuKGF1dG9GaWxsU3RhcnRUaW1lKT8gYXV0b0ZpbGxTdGFydFRpbWUgOiBkYXRlTWluO1xuICAgICAgICAgICAgZGF0ZU1heCA9IEJvb2xlYW4oYXV0b0ZpbGxFbmRUaW1lKT8gYXV0b0ZpbGxFbmRUaW1lIDogZGF0ZU1heDtcblxuICAgICAgICAgICAgLy8gU2V0IGVuZFRpbWUgdG8gY29uc3RydWN0IHNlcmllXG4gICAgICAgICAgICB2YXIgc2VyaWVFbmRUaW1lID0gQm9vbGVhbihhdXRvRmlsbEVuZFRpbWUpPyBkYXRlTWF4IDogZGF0ZU1heCArIGF1dG9GaWxsSW50ZXJ2YWw7XG5cbiAgICAgICAgICAgIC8vIFNldCB2YWx1ZU1pbiBhbmQgdmFsdWVNYXhcbiAgICAgICAgICAgIHZhbHVlTWluID0gTWF0aC5taW4odmFsdWVNaW4sIGF1dG9GaWxsVmFsdWUpO1xuICAgICAgICAgICAgdmFsdWVNYXggPSBNYXRoLm1heCh2YWx1ZU1heCwgYXV0b0ZpbGxWYWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aW1lIHJhbmdlXG4gICAgICAgICAgICB2YXIgdGltZVJhbmdlID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gZGF0ZU1pbjsgdCA8IHNlcmllRW5kVGltZTsgdCArPSBhdXRvRmlsbEludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdGltZVJhbmdlLnB1c2godCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbGwgY3VycmVudCBzZXJpZSB3aXRoIGV4aXN0aW5nIHBvaW50cyBvciB3aXRoIGF1dG9GaWxsVmFsdWVcbiAgICAgICAgICAgIHZhciBzZXJpZXNJbmRleCA9IDA7XG5cbiAgICAgICAgICAgIHNlcmllcyA9IHRpbWVSYW5nZS5tYXAoZnVuY3Rpb24odGltZSwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzW3Nlcmllc0luZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmIChCb29sZWFuKGRhdGEpICYmIChkYXRhLmRhdGUgPT0gdGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IG1pc3NpbmcgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiB0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBzZXJpZXNTdHlsZS5tYXAoZnVuY3Rpb24oc3R5bGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZTogc3R5bGUudGl0bGUgfHwgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF1dG9GaWxsVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBzdHlsZS5jb2xvciB8fCBkZWZhdWx0Q29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZU1heCA9PSB2YWx1ZU1pbikge1xuICAgICAgICAgICAgdmFsdWVNYXggPSB2YWx1ZU1pbiArIDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wdXRlIGF4ZSBzaXplc1xuICAgICAgICB2YXIgYXhlWEhlaWdodCA9IHByb3BzLnRleHRGb250U2l6ZSAqIDM7XG4gICAgICAgIHZhciBheGVZV2lkdGggID0gdmFsdWVNYXgudG9GaXhlZCgwKS5sZW5ndGggKiBwcm9wcy50ZXh0Rm9udFNpemUgKiAxLjUgKyBwcm9wcy5heGVNYXJrZXJXaWR0aDtcblxuICAgICAgICB2YXIgYXhlWExlbmd0aCA9IHdpZHRoIC0gMipwYWRkaW5nIC0gYXhlWVdpZHRoO1xuICAgICAgICB2YXIgYXhlWUxlbmd0aCA9IGhlaWdodCAtIDIqcGFkZGluZyAtIGF4ZVhIZWlnaHQ7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBib2R5IHNpemVcbiAgICAgICAgdmFyIGlubmVyWCA9IGF4ZVlXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIHZhciBpbm5lclkgPSBoZWlnaHQgLSAoYXhlWEhlaWdodCArIHBhZGRpbmcpO1xuXG4gICAgICAgIHZhciB5QmFzZSA9IHBhZGRpbmc7XG4gICAgICAgIHZhciB5VG9wICA9IGhlaWdodCAtIHBhZGRpbmc7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgc2VyaWVzLFxuICAgICAgICAgICAgZGF0ZU1pbixcbiAgICAgICAgICAgIGRhdGVNYXgsXG4gICAgICAgICAgICB2YWx1ZU1pbixcbiAgICAgICAgICAgIHZhbHVlTWF4LFxuICAgICAgICAgICAgYXhlWExlbmd0aCxcbiAgICAgICAgICAgIGF4ZVlMZW5ndGgsXG4gICAgICAgICAgICBpbm5lclgsXG4gICAgICAgICAgICBpbm5lclksXG4gICAgICAgICAgICB5VG9wLFxuICAgICAgICAgICAgeUJhc2VcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgd2lkdGggICAgICA9IHRoaXMuc3RhdGUud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgICAgID0gdGhpcy5zdGF0ZS5oZWlnaHQ7XG4gICAgICAgIHZhciBzZXJpZXMgICAgID0gdGhpcy5zdGF0ZS5zZXJpZXM7XG4gICAgICAgIHZhciBkYXRlTWluICAgID0gdGhpcy5zdGF0ZS5kYXRlTWluO1xuICAgICAgICB2YXIgZGF0ZU1heCAgICA9IHRoaXMuc3RhdGUuZGF0ZU1heDtcbiAgICAgICAgdmFyIHZhbHVlTWluICAgPSB0aGlzLnN0YXRlLnZhbHVlTWluO1xuICAgICAgICB2YXIgdmFsdWVNYXggICA9IHRoaXMuc3RhdGUudmFsdWVNYXg7XG4gICAgICAgIHZhciBheGVYTGVuZ3RoID0gdGhpcy5zdGF0ZS5heGVYTGVuZ3RoO1xuICAgICAgICB2YXIgYXhlWUxlbmd0aCA9IHRoaXMuc3RhdGUuYXhlWUxlbmd0aDtcbiAgICAgICAgdmFyIGlubmVyWCAgICAgPSB0aGlzLnN0YXRlLmlubmVyWDtcbiAgICAgICAgdmFyIGlubmVyWSAgICAgPSB0aGlzLnN0YXRlLmlubmVyWTtcbiAgICAgICAgdmFyIHlUb3AgICAgICAgPSB0aGlzLnN0YXRlLnlUb3A7XG4gICAgICAgIHZhciB5QmFzZSAgICAgID0gdGhpcy5zdGF0ZS55QmFzZTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9XCJ0aW1lLWdyYXBoXCIgd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gdmlld0JveD17JzAgMCAnK3dpZHRoKycgJytoZWlnaHR9IHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCI+XG4gICAgICAgICAgICAgICAgPFhBeGlzIGxlbmd0aD17YXhlWExlbmd0aH1cbiAgICAgICAgICAgICAgICAgICAgZGF0ZU1pbj17ZGF0ZU1pbn1cbiAgICAgICAgICAgICAgICAgICAgZGF0ZU1heD17ZGF0ZU1heH1cbiAgICAgICAgICAgICAgICAgICAgaW5uZXJYPXtpbm5lclh9XG4gICAgICAgICAgICAgICAgICAgIHlUb3A9e3lUb3B9IC8+XG4gICAgICAgICAgICAgICAgPFlBeGlzIGxlbmd0aD17YXhlWUxlbmd0aH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVNaW49e3ZhbHVlTWlufVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZU1heD17dmFsdWVNYXh9XG4gICAgICAgICAgICAgICAgICAgIGlubmVyWD17aW5uZXJYfVxuICAgICAgICAgICAgICAgICAgICBpbm5lclk9e2lubmVyWX1cbiAgICAgICAgICAgICAgICAgICAgeUJhc2U9e3lCYXNlfSAvPlxuICAgICAgICAgICAgICAgIDxCb2R5IHNlcmllcz17c2VyaWVzfVxuICAgICAgICAgICAgICAgICAgICBkYXRlTWluPXtkYXRlTWlufVxuICAgICAgICAgICAgICAgICAgICBkYXRlTWF4PXtkYXRlTWF4fVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZU1pbj17dmFsdWVNaW59XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlTWF4PXt2YWx1ZU1heH1cbiAgICAgICAgICAgICAgICAgICAgd2lkdGg9e2F4ZVhMZW5ndGh9XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodD17YXhlWUxlbmd0aH1cbiAgICAgICAgICAgICAgICAgICAgaW5uZXJYPXtpbm5lclh9XG4gICAgICAgICAgICAgICAgICAgIGlubmVyWT17aW5uZXJZfVxuICAgICAgICAgICAgICAgICAgICB5QmFzZT17eUJhc2V9IC8+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lR3JhcGg7XG4iXX0=