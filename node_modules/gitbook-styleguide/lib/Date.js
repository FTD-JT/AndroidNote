'use strict';

var React = require('react');
var moment = require('moment');
require('moment-duration-format');

var dateShape = React.PropTypes.oneOfType([React.PropTypes.number, React.PropTypes.string, React.PropTypes.instanceOf(Date)]);

/**
 * Render an updated relative date or with a specific format.
 *
 * Relative date: <Date date={new Date(...)} />
 * With format: <Date date={new Date(...)} format="%Y %M" />
 */
var DateSpan = React.createClass({
    displayName: 'DateSpan',


    contextTypes: {
        now: dateShape
    },

    getDefaultProps: function getDefaultProps() {
        return {
            format: '',
            refresh: 10 * 1000,
            utc: true
        };
    },
    getInitialState: function getInitialState() {
        return {
            now: 0
        };
    },
    tick: function tick() {
        this.setState({
            now: Date.now()
        });
    },
    componentDidMount: function componentDidMount() {
        var _props = this.props;
        var refresh = _props.refresh;
        var format = _props.format;

        // We tick only once to update date from utc to local

        if (format) {
            setTimeout(this.tick, 1000);
            return;
        }

        this.interval = setInterval(this.tick, refresh);
    },
    componentWillUnmount: function componentWillUnmount() {
        if (!this.interval) {
            return;
        }

        clearInterval(this.interval);
    },
    render: function render() {
        var now = this.state.now || this.context.now;
        var _props2 = this.props;
        var date = _props2.date;
        var format = _props2.format;
        var utc = _props2.utc;

        var displayDate = void 0;

        // Parse the date
        if (utc) {
            date = moment.utc(date);
        } else {
            date = moment(date);
        }

        // Apply formating if provided
        if (format) {
            // If client-side, we use the real date
            if (this.state.now) {
                date = date.local();
            }

            displayDate = date.format(format);
        } else {
            displayDate = date.from(now);
        }

        return React.createElement(
            'span',
            null,
            displayDate
        );
    }
});

/**
 * Render an updated duration.
 *
 * <Date.Duration duration={6000} />
 */
var DateDuration = React.createClass({
    displayName: 'DateDuration',
    getDefaultProps: function getDefaultProps() {
        return {
            format: 'h [hrs], m [min], s [sec]',
            refresh: 1000
        };
    },
    getInitialState: function getInitialState() {
        return {
            elapsed: 0
        };
    },
    tick: function tick() {
        var elapsed = this.state.elapsed;
        var refresh = this.props.refresh;


        this.setState({
            elapsed: elapsed + refresh
        });
    },
    componentDidMount: function componentDidMount() {
        var refresh = this.props.refresh;

        if (refresh > 0) {
            this.interval = setInterval(this.tick, refresh);
        }
    },
    componentWillUnmount: function componentWillUnmount() {
        clearInterval(this.interval);
    },
    render: function render() {
        var _props3 = this.props;
        var duration = _props3.duration;
        var format = _props3.format;
        var elapsed = this.state.elapsed;


        duration = duration + elapsed;

        return React.createElement(
            'span',
            null,
            moment.duration(duration).format(format)
        );
    }
});

var DateContext = React.createClass({
    displayName: 'DateContext',


    childContextTypes: {
        now: dateShape
    },

    getChildContext: function getChildContext() {
        return {
            now: this.props.now
        };
    },
    render: function render() {
        return React.Children.only(this.props.children);
    }
});

module.exports = DateSpan;
module.exports.shape = dateShape;
module.exports.Context = DateContext;
module.exports.Duration = DateDuration;
//# sourceMappingURL=data:application/json;base64,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QSxPQUFPLE9BQVAsQ0FBZSxPQUFmLEdBQTBCLFdBQTFCO0FBQ0EsT0FBTyxPQUFQLENBQWUsUUFBZixHQUEwQixZQUExQiIsImZpbGUiOiJEYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5yZXF1aXJlKCdtb21lbnQtZHVyYXRpb24tZm9ybWF0Jyk7XG5cbmNvbnN0IGRhdGVTaGFwZSA9IFJlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgIFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBSZWFjdC5Qcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKVxuXSk7XG5cbi8qKlxuICogUmVuZGVyIGFuIHVwZGF0ZWQgcmVsYXRpdmUgZGF0ZSBvciB3aXRoIGEgc3BlY2lmaWMgZm9ybWF0LlxuICpcbiAqIFJlbGF0aXZlIGRhdGU6IDxEYXRlIGRhdGU9e25ldyBEYXRlKC4uLil9IC8+XG4gKiBXaXRoIGZvcm1hdDogPERhdGUgZGF0ZT17bmV3IERhdGUoLi4uKX0gZm9ybWF0PVwiJVkgJU1cIiAvPlxuICovXG5jb25zdCBEYXRlU3BhbiA9ICBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIC8vIERhdGUgdG8gZGlzcGxheVxuICAgICAgICBkYXRlOiAgICBkYXRlU2hhcGUuaXNSZXF1aXJlZCxcbiAgICAgICAgLy8gSW50ZXJ2YWwgdG8gcmVmcmVzaCB0aGUgZGlzcGxheVxuICAgICAgICByZWZyZXNoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAvLyBGb3JtYXQgZm9yIG91dHB1dFxuICAgICAgICBmb3JtYXQ6ICBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAvLyBJcyB0aGUgZGF0ZSBpbiBVVEMgb3IgTG9jYWxcbiAgICAgICAgdXRjOiAgICAgUmVhY3QuUHJvcFR5cGVzLmJvb2xcbiAgICB9LFxuXG4gICAgY29udGV4dFR5cGVzOiB7XG4gICAgICAgIG5vdzogZGF0ZVNoYXBlXG4gICAgfSxcblxuICAgIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogICAnJyxcbiAgICAgICAgICAgIHJlZnJlc2g6IDEwKjEwMDAsXG4gICAgICAgICAgICB1dGM6ICAgICAgdHJ1ZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub3c6IDBcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgdGljaygpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBub3c6IERhdGUubm93KClcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCB7IHJlZnJlc2gsIGZvcm1hdCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICAvLyBXZSB0aWNrIG9ubHkgb25jZSB0byB1cGRhdGUgZGF0ZSBmcm9tIHV0YyB0byBsb2NhbFxuICAgICAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMudGljaywgMTAwMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy50aWNrLCByZWZyZXNoKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnRlcnZhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBub3cgPSB0aGlzLnN0YXRlLm5vdyB8fCB0aGlzLmNvbnRleHQubm93O1xuICAgICAgICBsZXQgeyBkYXRlLCBmb3JtYXQsIHV0YyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGRpc3BsYXlEYXRlO1xuXG4gICAgICAgIC8vIFBhcnNlIHRoZSBkYXRlXG4gICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgIGRhdGUgPSBtb21lbnQudXRjKGRhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG1vbWVudChkYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGx5IGZvcm1hdGluZyBpZiBwcm92aWRlZFxuICAgICAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICAvLyBJZiBjbGllbnQtc2lkZSwgd2UgdXNlIHRoZSByZWFsIGRhdGVcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm5vdykge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBkYXRlLmxvY2FsKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpc3BsYXlEYXRlID0gZGF0ZS5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3BsYXlEYXRlID0gZGF0ZS5mcm9tKG5vdyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPHNwYW4+e2Rpc3BsYXlEYXRlfTwvc3Bhbj47XG4gICAgfVxufSk7XG5cbi8qKlxuICogUmVuZGVyIGFuIHVwZGF0ZWQgZHVyYXRpb24uXG4gKlxuICogPERhdGUuRHVyYXRpb24gZHVyYXRpb249ezYwMDB9IC8+XG4gKi9cbmNvbnN0IERhdGVEdXJhdGlvbiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgZHVyYXRpb246IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGZvcm1hdDogICBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICByZWZyZXNoOiAgUmVhY3QuUHJvcFR5cGVzLm51bWJlclxuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6ICdoIFtocnNdLCBtIFttaW5dLCBzIFtzZWNdJyxcbiAgICAgICAgICAgIHJlZnJlc2g6IDEwMDBcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWxhcHNlZDogMFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICB0aWNrKCkge1xuICAgICAgICBjb25zdCB7IGVsYXBzZWQgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgcmVmcmVzaCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGVsYXBzZWQ6IGVsYXBzZWQgKyByZWZyZXNoXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyByZWZyZXNoIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAocmVmcmVzaCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLnRpY2ssIHJlZnJlc2gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IGR1cmF0aW9uLCBmb3JtYXQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgZWxhcHNlZCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uICsgZWxhcHNlZDtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHNwYW4+e21vbWVudC5kdXJhdGlvbihkdXJhdGlvbikuZm9ybWF0KGZvcm1hdCl9PC9zcGFuPlxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG5jb25zdCBEYXRlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgY2hpbGRyZW46IFJlYWN0LlByb3BUeXBlcy5ub2RlLFxuICAgICAgICBub3c6ICAgICAgZGF0ZVNoYXBlXG4gICAgfSxcblxuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgICAgIG5vdzogZGF0ZVNoYXBlXG4gICAgfSxcblxuICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vdzogdGhpcy5wcm9wcy5ub3dcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFJlYWN0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbikpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyAgICAgICAgICA9IERhdGVTcGFuO1xubW9kdWxlLmV4cG9ydHMuc2hhcGUgICAgPSBkYXRlU2hhcGU7XG5tb2R1bGUuZXhwb3J0cy5Db250ZXh0ICA9IERhdGVDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMuRHVyYXRpb24gPSBEYXRlRHVyYXRpb247XG4iXX0=